<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on Kiss&#39;Em!</title>
    <link>https://example.com/note/</link>
    <description>Recent content in Notes on Kiss&#39;Em!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 28 Dec 2020 21:48:16 +0800</lastBuildDate><atom:link href="https://example.com/note/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>tps、qps</title>
      <link>https://example.com/note/computerscience/tpsqps/</link>
      <pubDate>Mon, 28 Dec 2020 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/computerscience/tpsqps/</guid>
      <description>什么是TPS，什么是QPS，区别是什么 一、TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）
TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。
一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。
二、QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。
对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</description>
    </item>
    
    <item>
      <title>Windows-kill-port</title>
      <link>https://example.com/note/computerscience/windows%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Sat, 28 Nov 2020 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/computerscience/windows%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/</guid>
      <description>windows根据端口杀死进程
# 列出进程极其占用的端口，且包含 80 netstat -ano | findstr 80 # 根据pid查进程 tasklist | findstr 2000 # 杀死进程 taskkill -PID &amp;lt;进程号&amp;gt; -F </description>
    </item>
    
    <item>
      <title>Centos7升级python2到python3</title>
      <link>https://example.com/note/backend/linux/centos7-update-python2-to-python3/</link>
      <pubDate>Sat, 06 Jul 2019 23:54:30 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/centos7-update-python2-to-python3/</guid>
      <description>服务器自带的python版本为2.7,需要升级到python3,遇到了一些坑,记录一下.
准备工作 安装和编译工作很顺利,但是发现pip版本不能被正确安装,出现下面的错误
Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; File &amp;quot;/usr/local/lib/python3.4/multiprocessing/context.py&amp;quot;, line 132, in Value from .sharedctypes import Value File &amp;quot;/usr/local/lib/python3.4/multiprocessing/sharedctypes.py&amp;quot;, line 10, in &amp;lt; module&amp;gt; import ctypes File &amp;quot;/usr/local/lib/python3.4/ctypes/__init__.py&amp;quot;, line 7, in &amp;lt;module&amp;gt; from _ctypes import Union, Structure, Array ImportError: No module named &#39;_ctypes&#39; 查阅资料发现需要提前安装好一个依赖,pip才可以被正确安装
yum install libffi-devel 安装 # 下载 wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz #解压源码包 tar -zxvf Python-3.7.0.tgz #创建安装目录 mkdir /usr/local/python3 cd Python-3.7.0/ #安装到指定目录 ./configure --prefix=/usr/local/python3 # 编译 make &amp;amp;&amp;amp; make install 后续工作 设置软链接使得全局使用python3 cd /usr/local/python3 ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3 ln -s /usr/local/bin/pip3 /usr/bin/pip 不知道pip安装位置的,可以使用命令来查看安装位置</description>
    </item>
    
    <item>
      <title>Dockerfile入门</title>
      <link>https://example.com/note/backend/docker/dockerfile-use/</link>
      <pubDate>Mon, 18 Feb 2019 23:26:39 +0000</pubDate>
      
      <guid>https://example.com/note/backend/docker/dockerfile-use/</guid>
      <description>Dockerfile的操作 定制镜像 镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。
Docker 常用镜像的构建 使用jdk8和tomcat8.5构建基础镜像 # make jdk-tomcat8 imageFROMopenjdk:8-jdk-alpineMAINTAINERhaigeek# now add java and tomcat support in the container ADD apache-tomcat-8.5.38.tar.gz /usr/local/ RUN cd /usr/local/ \  &amp;amp;&amp;amp; rm -f apache-tomcat-8.5.38.tar.gz# configuration of java and tomcat ENV ENV CATALINA_HOME /usr/local/apache-tomcat-8.5.38ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin # container listener port EXPOSE8080# startup web application services by self CMD /usr/local/apache-tomcat-8.5.38/bin/catalina.sh runfrom 指定基础镜像 From指定一个基础镜像，在其上进行定制，基础镜像必须指定而且必须是第一条指令 在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</description>
    </item>
    
    <item>
      <title>docker私有仓库</title>
      <link>https://example.com/note/backend/docker/docker-registry/</link>
      <pubDate>Sun, 17 Feb 2019 23:26:39 +0000</pubDate>
      
      <guid>https://example.com/note/backend/docker/docker-registry/</guid>
      <description>docker 私有仓库 创建私有仓库 docker run -d -p 5000:5000 &amp;ndash;restart=always -v /opt/data/registry:/var/lib/registry &amp;ndash;name registry registry
-d 后台运行
-p 5000:5000 端口映射
-v /opt/data/registry:/var/lib/registry 将docker中的镜像仓库文件镜像地址映射到宿主机的 /opt/data/registry 文件夹
-name registry 文件启动名称
上传镜像到私有仓库 1、为镜像打tag 将本地镜像标记为私有仓库的镜像
docker tag hello-docker:latest 127.0.0.1:5000/hello-docker:latest
2、上传镜像到私有仓库 docker push 127.0.0.1/hello-docker:latest
3、验证镜像是否成功上传到私有仓库 curl 127.0.0.1:5000/v2/_catalog
或者打开浏览器 访问http://127.0.0.1:5000/v2/_catalog 查看输出
取消HTTPS 上传限制 如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。
客户端从私有仓库上pull镜像 修改etc/sysconfig/docker配置文件
添加如下内容
OPTIONS=’–insecure-registry 192.168.1.40:5000′（IP地址及端口，可根据实际情况填写）
修改后，重启docker服务
私有仓库镜像的删除 删除需要进行两步操作
 使用删除api进行镜像的删除 进入镜像文件夹进行垃圾回收  </description>
    </item>
    
    <item>
      <title>Ajax基础知识</title>
      <link>https://example.com/note/web/ajax-base/</link>
      <pubDate>Wed, 16 Jan 2019 23:26:39 +0000</pubDate>
      
      <guid>https://example.com/note/web/ajax-base/</guid>
      <description>AJAX 什么是ajax Asynchronous JavaScript and XML，用JavaScript执行异步网络请求。传统的http是一个请求对应一个http页面，为了使得用户可以留在当前页面，同时发出新的http 请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面。
AJAX是异步进行执行的，所以需要回调函数获取响应。
在现代浏览器上写AJAX主要依靠XMLHttpRequest对象：
function success(text) { var textarea = document.getElementById(&amp;#39;test-response-text&amp;#39;); textarea.value = text; } function fail(code) { var textarea = document.getElementById(&amp;#39;test-response-text&amp;#39;); textarea.value = &amp;#39;Error code: &amp;#39; + code; } var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象  request.onreadystatechange = function () { // 状态发生变化时，函数被回调  if (request.readyState = 4) { // 成功完成  // 判断响应结果:  if (request.status = 200) { // 成功，通过responseText拿到响应的文本:  return success(request.</description>
    </item>
    
    <item>
      <title>docker下oracle数据库导入</title>
      <link>https://example.com/note/database/oracle/docker%E4%B8%8Boracle%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 27 Dec 2018 22:03:05 +0800</pubDate>
      
      <guid>https://example.com/note/database/oracle/docker%E4%B8%8Boracle%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/</guid>
      <description>docker下oracle数据库导入 进入oracle docker环境   假如使用的oracle镜像版本为：wnameless/oracle-xe-11g 这个镜像进入bash默认的用户为root，需要切换到oracle用户下进行操作 *   进入容器 docker exec -it containerid bash # 切换为oracle用户 su - oracle #设置环境变量（设置过可忽略） export ORACLE_SID=orcl export ORACLE_HOME=/u01/app/oracle/product/11.2.0/xe export PATH=$ORACLE_HOME/bin:$PATH 使用impdp方式进行数据的导入 # 创建表空间 create tablespace dgpdg logging datafile &amp;#39;/u01/app/oracle/oradata/XE/dgpdg.dbf&amp;#39; size 1500m autoextend on next 100m maxsize 10000m extent management local; # 创建用户并配置表空间，授权 create user dgpdg identified by pass DEFAULT TABLESPACE dgpdg; grant dba to dgpdg; # 创建dump目录,并将dmp文件放在该文件夹下 create directory dmp_dir as &amp;#39;/u01/app/oracle/dump&amp;#39; # 授权目录读写权限 grant read,write on directory dmp_dir to dgpdg; # impdp方式导入 impdp dgpsd/pass directory=dmp_dir dumpfile=DGPDG20181009.</description>
    </item>
    
    <item>
      <title>hibernate的一级缓存与二级缓存</title>
      <link>https://example.com/note/java/javaweb/hibernate/hibernate%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</link>
      <pubDate>Wed, 01 Aug 2018 22:21:02 +0800</pubDate>
      
      <guid>https://example.com/note/java/javaweb/hibernate/hibernate%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</guid>
      <description>hibernate的一级缓存与二级缓存 什么是缓存 缓存是介于物理数据源与应用程序之间，是对数据库中的数据复制一份临时放在内存中的容器，其作用是为了减少应用程序对物理数据源访问的次数，从而提高了应用程序的运行性能。Hibernate 在进行读取数据的时候，根据缓存机制在相应的缓存中查询，如果在缓存中找到了需要的数据 (我们把这称做 “缓存命中 &amp;ldquo;)，则就直接把命中的数据作为结果加以利用，避免了大量发送 SQL 语句到数据库查询的性能损耗。
缓存策略提供商： 提供了 HashTable 缓存，EHCache，OSCache，SwarmCache，jBoss Cathe2，这些缓存机制，其中 EHCache，OSCache 是不能用于集群环境（Cluster Safe）的，而 SwarmCache，jBoss Cathe2 是可以的。HashTable 缓存主要是用来测试的，只能把对象放在内存中，EHCache，OSCache 可以把对象放在内存（memory）中，也可以把对象放在硬盘（disk）上（为什么放到硬盘上？上面解释了）。
一级缓存 定义 一级缓存是Session 缓存（又称作事务缓存）：Hibernate 内置的，不能卸除。
缓存范围：缓存只能被当前 Session 对象访问。缓存的生命周期依赖于 Session 的生命周期，当 Session 被关闭后，缓存也就结束生命周期。
实例 Hibernate 一些与一级缓存相关的操作（时间点）：
数据放入缓存：
1、save()。当 session 对象调用 save() 方法保存一个对象后，该对象会被放入到 session 的缓存中。
2、get() 和 load()。当 session 对象调用 get() 或 load() 方法从数据库取出一个对象后，该对象也会被放入到 session 的缓存中。
3、使用 HQL 和 QBC 等从数据库中查询数据。
使用 get() 或 load() 证明缓存的存在：
public class Client { public static void main(String[] args) { Session session = HibernateUtil.</description>
    </item>
    
    <item>
      <title>Redis的数据类型</title>
      <link>https://example.com/note/database/redis/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 27 May 2018 22:03:05 +0800</pubDate>
      
      <guid>https://example.com/note/database/redis/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Redis的数据类型 Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
String String是Redis最基本的类型，一个key对应一个value，String可以包含任何数据，例如jpg图片或者序列化的对象，string 类型可以存储最大的数据值是512MB
127.0.0.1:6379&amp;gt; set name &amp;#34;hello&amp;#34; OK 127.0.0.1:6379&amp;gt; get name &amp;#34;hello&amp;#34; Hash Redis hash 是一个键值(key=&amp;gt;value)对集合，是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&amp;gt;value 对, HGET 获取对应 field 对应的 value。 每个 hash 可以存储 2的32次方减1个键值对（40多亿）。
127.0.0.1:6379&amp;gt; hmset myhash field1 &amp;#34;hello&amp;#34; field2 &amp;#34;world&amp;#34; OK 127.0.0.1:6379&amp;gt; hget myhash field1 &amp;#34;hello&amp;#34; 127.0.0.1:6379&amp;gt; hget myhash field2 &amp;#34;world&amp;#34; Set Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 添加数据使用sadd 命令。添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</description>
    </item>
    
    <item>
      <title>redis的安装和配置</title>
      <link>https://example.com/note/database/redis/redis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 27 Apr 2018 22:03:05 +0800</pubDate>
      
      <guid>https://example.com/note/database/redis/redis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid>
      <description>redis的安装和配置  参考 http://www.runoob.com/redis/redis-conf.html
 安装 使用homebrew安装
brew install redis 安装完毕后提示
To have launchd start redis now and restart at login: brew services start redis Or, if you don&amp;#39;t want/need a background service you can just run: redis-server /usr/local/etc/redis.conf 配置 启动服务端 redis-server 启动客户端 redis-cli 查看配置 # 查看某一项配置 CONFIG GET loglevel # 查看所有配置 CONFIG GET * 修改配置 可以通过修改conf文件或者使用命令进行配置的修改
CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE 配置说明   Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no
  当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.</description>
    </item>
    
    <item>
      <title>redis-shell</title>
      <link>https://example.com/note/database/redis/redis%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Wed, 11 Apr 2018 22:03:05 +0800</pubDate>
      
      <guid>https://example.com/note/database/redis/redis%E6%8C%87%E4%BB%A4/</guid>
      <description>redis 指令 启动 # 本地启动 redis-cli ## 远程启动 redis-cli -h host -p port -a password </description>
    </item>
    
    <item>
      <title>oracle的expdp impdp</title>
      <link>https://example.com/note/database/oracle/oracle-expdp-impdp%E6%95%B0%E6%8D%AE%E6%B3%B5/</link>
      <pubDate>Tue, 27 Mar 2018 22:03:05 +0800</pubDate>
      
      <guid>https://example.com/note/database/oracle/oracle-expdp-impdp%E6%95%B0%E6%8D%AE%E6%B3%B5/</guid>
      <description>expdp impdp使用 参考 http://blog.51cto.com/yemingtian/1851919
创建远程连接 假如我需要拷贝远程的数据库数据并将其迁移到我本机上，那么我不需要登录远程服务器，直接在本机与远程数据库建立连接即可 create public database link connect to DGPDG identified by pass using &amp;lsquo;ip address/orcl&amp;rsquo;;
创建导出目录 创建逻辑目录，该命令不会在操作系统创建真正的目录（最好手工先建好），最好以administrator等管理员创建。
SQL&amp;gt;create directory dir as &#39;d:\dump&#39;; --dir名称可以随便命名 是oracle可识别的名字 但是存储目录 d:\dump 需要在系统硬盘上手工创建
向用户授权读写目录 给用户赋予在指定目录下的读写权限
Grant read,write on directory dir_name to user_name;
执行导出  按照表模式导出 按照查询条件导出 按照表空间导出 按照用户导出 导出整个数据库  执行导入  按照表导入 按照用户导入 按照表空间导入 全库导入  转换表空间迁移数据 expdp system/sys directory=dir_dp dumpfile=dgpfp.dmp logfile=dgpdg20171115.log SCHEMAS=dgpfp
总结： 执行impdp时无需创建b用户，在导入时会自动创建并改名用户a为b（拥有a的所有权限等），自动设置默认表空间为转换后的表空间b。如果有多个表空间需要转换，则使用多个remap_tablespace=源表空间：目标表空间。此种方法只限于支持oracle10g以上版本。
expdp system/sys directory=exp_dir dumpfile=dgpfp.dmp logfile=dgpfp20180411.log SCHEMAS=dgpfp create directory expdir as &#39;D:/exp_dir&#39;; expdp system/sys@orcl directory=expdir dumpfile=dgpfp20180411.</description>
    </item>
    
    <item>
      <title>c pointer</title>
      <link>https://example.com/note/computerscience/c%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 28 Dec 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/computerscience/c%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80/</guid>
      <description>c语言指针基础知识 指针，引用和取值  指针是一个存储计算机内存地址的变量，可以用引用表示计算机的内存地址；从指针指向的内存读取的数据成为指针的取值 指针可以指向某些具体类型的变量地址，例如int，long和double；指针也可以是void类型，NULL指针和未初始化指针 根据出现位置的不同，操作符*既可以用来声明一个指针变量，也可以用作当做指针的取值。当在声明一个变量时， *表示这里声明了一个指针。其他情况用 *表示指针的取值。 &amp;amp;是地址操作符，用来引用一个内存地址。通用在变量名字前使用&amp;amp;操作符，我们可以得到该内存的内存地址。  int *ptr;//声明一个int指针 int val=1;//声明一个int值 ptr=&amp;amp;val;//为指针分配一个int值的引用 int deref=*ptr; printf(&amp;#34;%d\n&amp;#34;,deref);//对指针进行取值,打印存储在指针地址中的内容 void指针，NULL指针和未初始化指针 一个指针可以被声明为void类型，比如void *x；一个指针可以被赋值为NULL；一个指针声明之后但没有被赋值，叫做未初始化指针
int *uninit;//int指针未初始化 int *nullptr=NULL;//初始化未NULL void *vptr;//void指针未初始化 int val=1; int *iptr; int *castptr; //void类型可以存储为任意类型的指针或者引用 iptr=&amp;amp;val; vptr=iptr; printf(&amp;#34;iptr=%p,vptr=%p\n&amp;#34;,iptr,vptr); //通过显式转换，可以把一个void指针转换为int指针，并取值 castptr=(int*)vptr; printf(&amp;#34;*castptr=%d\n&amp;#34;,*castptr); //打印null和未初始化指针 printf(&amp;#34;uninit=%p,nillptr=%p\n&amp;#34;,uninit,nullptr); 指针和数组 数组和指针不是同一种结构因此不可以相互转换，而数组变量指向了数组的第一个元素的内存地址；不能把指针赋值给数组变量，也不可以将一个数组变量赋值给另外一个数组，然而可以将一个数组变量赋值给指针。把数组变量赋值给指针的时候，实际上是把指向数组的第一个元素的地址赋给指针。
int array[4]={1,2,3,0}; int *ptr=array;//这个赋值与int *ptr=&amp;amp;array[0]效果相同；需要注意指针需要和数组的元素类型保持一致 指针和结构体 就像数组一样，指向结构体的指针存储了结构体第一个元素的内存地址。与数组指针一样，结构体的指针必须声明和结构体类型保持一致，或者声明为void类型。
struct person{ int age; char *name; }; struct person first; struct person *ptr; first.age=21; char *fullname=&amp;#34;full name&amp;#34;; first.name=fullname; ptr=&amp;amp;first; printf(&amp;#34;age=%d,name=%s\n&amp;#34;,first.</description>
    </item>
    
    <item>
      <title>Introduction to Data Structure</title>
      <link>https://example.com/note/computerscience/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/</link>
      <pubDate>Thu, 28 Dec 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/computerscience/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/</guid>
      <description>数据结构绪论  数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 数据元素：是组成数据，有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 数据项：一个数据元素可以由多个数据项组成，数据项是不可分割的最小单位 数据对象：是性质相同的数据元素的集合，是数据的子集 数据结构：是相互之间存在一种或者多种特定关系数据元素的集合 数据结构的分类： 逻辑结构：  集合结构 线性结构 树形结构 图形结构   物理结构  顺序存储结构 链接存储结构    </description>
    </item>
    
    <item>
      <title>mongodb基本操作</title>
      <link>https://example.com/note/database/mongodb/mongodb%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 28 Dec 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/database/mongodb/mongodb%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</guid>
      <description>mongodb基本操作 数据库与集合 数据库连接 在终端连接mongo
mongo 192.168.1.110:27017 创建数据库  use DATABASE_NAME 创建数据库，如果数据已经存在，切换到对应的数据库 show dbs显示所有的数据库 db.DATABASE_NAME.insert({&amp;quot;name&amp;quot;:&amp;quot;名称&amp;quot;}) 插入数据，默认的数据库为test  删除数据库  db.dropDatebase() 在执行数据库删除的时候，需要先切换到对于的数据库  创建集合  db.createCollection(name, options) name表示要创建的集合的名称，options表示可选的参数 options参数主要有以下几个参数 capped 布尔型 如果为true，则创建固定集合，并必须制定size参数的大小，当集合达到最大值的时候，会自动覆盖之前的文档 autoIndexId 布尔型 可以自动在_id字段创建索引，默认为false size 数值型 为固定集合指定一个最大值（以字节计）。 max 数值型 指定固定集合中包含文档的最大数量。  删除集合  show collection 查看集合 db.collection.drop() 删除集合  文档操作 MongoDB里的文档数据结构和JSON基本一致，所有存储在集合中的数据称为BSON格式，BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。
插入文档  db.COLLECTION_NAME.insert(document) 使用insert()或者save()方法进行插入,在进行插入的时候，假如集合不在数据库中，MongoDB 会自动创建该集合并插入文档。 可以将数据定义为一个变量，再执行插入操作，将该变量插入。  更新文档 update()来进行文档的更新，更新格式如下
db.collection.update( &amp;lt;query&amp;gt;, &amp;lt;update&amp;gt;, { upsert: &amp;lt;boolean&amp;gt;, multi: &amp;lt;boolean&amp;gt;, writeConcern: &amp;lt;document&amp;gt; } ) 参数说明：</description>
    </item>
    
    <item>
      <title>mongoDB数据库备份与恢复</title>
      <link>https://example.com/note/database/mongodb/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</link>
      <pubDate>Thu, 28 Dec 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/database/mongodb/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</guid>
      <description>mongoDB数据库备份与恢复 备份
 mongodump -h 192.168.1.194:17017 -d ims_sheng --gzip --archive=/Users/haigeek/Downloads/test/ims_sheng.gz 恢复
mongorestore -h 127.0.0.1:27017 --gzip --archive=/Users/haigeek/Downloads/test/ims_sheng.gz --nsFrom &amp;quot;ims_sheng.*&amp;quot; --nsTo &amp;quot;ims_wh.*&amp;quot; --nsInclude &amp;quot;*&amp;quot; </description>
    </item>
    
    <item>
      <title>mongo常用增删改查</title>
      <link>https://example.com/note/database/mongodb/mongo%E5%B8%B8%E7%94%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</link>
      <pubDate>Thu, 28 Dec 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/database/mongodb/mongo%E5%B8%B8%E7%94%A8%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</guid>
      <description>常用操作对照 db.users.find() select * from users db.users.find({&amp;#34;age&amp;#34; : 27}) select * from users where age = 27 db.users.find({&amp;#34;username&amp;#34; : &amp;#34;joe&amp;#34;, &amp;#34;age&amp;#34; : 27}) select * from users where &amp;#34;username&amp;#34; = &amp;#34;joe&amp;#34; and age = 27 db.users.find({}, {&amp;#34;username&amp;#34; : 1, &amp;#34;email&amp;#34; : 1}) select username, email from users db.users.find({}, {&amp;#34;username&amp;#34; : 1, &amp;#34;_id&amp;#34; : 0}) // no case // 即时加上了列筛选，_id也会返回；必须显式的阻止_id返回 db.users.find({&amp;#34;age&amp;#34; : {&amp;#34;$gte&amp;#34; : 18, &amp;#34;$lte&amp;#34; : 30}}) select * from users where age &amp;gt;=18 and age &amp;lt;= 30 // $lt(&amp;lt;) $lte(&amp;lt;=) $gt(&amp;gt;) $gte(&amp;gt;=) db.</description>
    </item>
    
    <item>
      <title>mongo开启安全验证</title>
      <link>https://example.com/note/database/mongodb/mongo%E5%BC%80%E5%90%AF%E5%AE%89%E5%85%A8%E9%AA%8C%E8%AF%81/</link>
      <pubDate>Thu, 28 Dec 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/database/mongodb/mongo%E5%BC%80%E5%90%AF%E5%AE%89%E5%85%A8%E9%AA%8C%E8%AF%81/</guid>
      <description>mongo开启安全验证 开启mongodb安全验证（参考https://docs.mongodb.com/guides/server/auth/）
xxx代表要设置的密码
windows   cmd中启动mongodb
&amp;quot;C:\Program Files\MongoDB\Server\3.4\bin\mongod.exe&amp;quot; --dbpath=&amp;quot;C:\MongoDB\data&amp;quot; --logpath=&amp;quot;C:\MongoDB\logs\mongodb.log&amp;quot;   登录客户端mongo.exe,设置用户密码
  Switch to the admin Database
use admin   Create the user administrator
 db.createUser( { user: &amp;quot;mySuperAdmin&amp;quot;, pwd: &amp;quot;xxx&amp;quot;, roles: [ { role: &amp;quot;userAdminAnyDatabase&amp;quot;, db: &amp;quot;admin&amp;quot; } ] } )   Create a user for reading and writing to your test database
db.createUser( { user: &amp;quot;userReadWrite&amp;quot;, pwd: &amp;quot;xxx&amp;quot;, roles: [ { role: &amp;quot;readWriteAnyDatabase&amp;quot;, db: &amp;quot;admin&amp;quot; } ] } ) db.</description>
    </item>
    
    <item>
      <title>mongo用户操作</title>
      <link>https://example.com/note/database/mongodb/mongo%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 28 Dec 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/database/mongodb/mongo%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C/</guid>
      <description>Mongo用户操作 新建管理员用户
use admin db.createUser( { user: &amp;quot;adminuser&amp;quot;, pwd: &amp;quot;passw0rd&amp;quot;, roles: [ { role: &amp;quot;userAdminAnyDatabase&amp;quot;, db: &amp;quot;admin&amp;quot; } ] } ) db.auth(&#39;adminuser&#39;,&#39;passw0rd&#39;)  新建普通用户
db.createUser( { user: &amp;quot;xxx&amp;quot;, pwd: &amp;quot;xxx&amp;quot;, roles: [ { role: &amp;quot;dbOwner&amp;quot;, db: &amp;quot;ims_jxsj&amp;quot; } ] } ) 查看所有用户
db.system.users.find().pretty() 删除用户
 db.dropUser(&#39;userims_jxsj&#39;) </description>
    </item>
    
    <item>
      <title>mongo的视图操作</title>
      <link>https://example.com/note/database/mongodb/mongo%E7%9A%84%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Thu, 28 Dec 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/database/mongodb/mongo%E7%9A%84%E8%A7%86%E5%9B%BE/</guid>
      <description>在mongo中可以创建视图
视图是只读的
 db.createView(&amp;quot;dus_apply_view&amp;quot;,&amp;quot;dus_apply&amp;quot;, [	{ $lookup:{from:&amp;quot;dus_proxy&amp;quot;,localField:&amp;quot;serviceId&amp;quot;,foreignField:&amp;quot;_id&amp;quot;,as:&amp;quot;embedProxy&amp;quot;} }, { $project:{&amp;quot;embedProxy._id&amp;quot;:0} // 设置不需要哪些字段 }, { $addFields: { &amp;quot;_id&amp;quot;: { &amp;quot;$toString&amp;quot;: &amp;quot;$_id&amp;quot; } } }, { $lookup:{from:&amp;quot;dus_apply_log&amp;quot;,localField:&amp;quot;_id&amp;quot;,foreignField:&amp;quot;applyId&amp;quot;,as:&amp;quot;embedApplyLog&amp;quot;} }, { $project:{&amp;quot;embedApplyLog._id&amp;quot;:0} // 设置不需要哪些字段 } ] ) 参数说明：
dus_apply_view：要创建的视图的名称</description>
    </item>
    
    <item>
      <title>oracleQ&amp;A</title>
      <link>https://example.com/note/database/oracle/oracle%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 27 Dec 2017 22:03:05 +0800</pubDate>
      
      <guid>https://example.com/note/database/oracle/oracle%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</guid>
      <description>在删除oracle用户的时候，出现无法连接正在连接的用户 select username,sid,serial# from v$session; alter system kill session&#39;94,229&#39; drop user dgpcd cascade ; Oracle数据库监听配置常见问题  ORA-12710 连接超时   解决：可能是防火墙问题，在入站规则添加对应的端口即可，默认端口为1521
  ORA-12514 TNS 监听程序当前无法识别连接描述符中请求服务   解决：使用net configuration assistant重新配置本地网络名配置
  使局域网的电脑可以访问本机的数据库   在服务端的listener.ora文件进行如下编辑，除了localhost之外，添加一行地址设置本机ip
 LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521)) ) (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)) (ADDRESS = (PROTOCOL = TCP)(HOST = 你的主机IP地址)(PORT = 1521)) ) ) </description>
    </item>
    
    <item>
      <title>oracle的case、if</title>
      <link>https://example.com/note/database/oracle/oracle%E4%B8%AD%E7%9A%84case%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Wed, 27 Dec 2017 22:03:05 +0800</pubDate>
      
      <guid>https://example.com/note/database/oracle/oracle%E4%B8%AD%E7%9A%84case%E8%AF%AD%E5%8F%A5/</guid>
      <description>PL/SQL中的case语句和if语句 case语句存在两种形式：case和搜索式case，case语句可以设定选择器， 选择器会决定需要执行哪组动作，而搜索式case语句没有选择器，搜索条件会按顺序计算，从而决定采取哪组动作。
case语句 case语句的结构
case selector when expression1 then statement1; when expression2 then statement2; ... when expression n then statement n; else statement N+1 end case; 选择器决定哪个WHEN子句应该被执行，每个WHEN子句都包含一个EXPRESSION以及与之关联的一个或者多个可执行语句，else语句是可选的；选择器只会计算一次，会顺序计算WHEN子句，表达式的值与选择器的值进行比较
搜索式case语句 搜索式语句有个能产生布尔值的搜索条件，当特定的搜索条件的计算结果为TURE时，会执行与该条件相关的语句组合。
搜索式case语句的结构：
case when search condition 1 then statement 1; when search condition 2 then statement 2; ... when search condition n then statement n; else statement N+1; end case; 当搜索条件的计算结果为true时，执行控制权传递给相关的语句，如果任何搜索条件都不会产生true，则会执行与else子句相关的语句
case语句和搜索式case语句的差别 搜索式case语句没有选择器，除此之外，它的when子句能够产生布尔值的搜索条件（类似if语句）而不会生成任意类型值的表达式
case表达式 在case语句中，when和else子句包含一个可执行的语句，每个可执行语句的结尾处都是分号，在case表达式中，when和else子句包含的表达式的结尾处不是分号，分号出现在保留字end后面，end终止case表达式
case when 在语句中不同位置的用法   select case when 用法</description>
    </item>
    
    <item>
      <title>Print linked list from end to beginning</title>
      <link>https://example.com/note/computerscience/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/%E4%BB%8E%E5%90%8E%E5%BE%80%E5%89%8D%E8%BE%93%E5%87%BA%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 27 Dec 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/computerscience/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/%E4%BB%8E%E5%90%8E%E5%BE%80%E5%89%8D%E8%BE%93%E5%87%BA%E9%93%BE%E8%A1%A8/</guid>
      <description>剑指offer面试题5&amp;ndash;从尾到头打印链表 题目 输入一个链表，从尾到头打印链表每个节点的值。
解题思路  输出链表的值可以采用遍历的方法。但是遍历是从头到尾，因此可以采用栈的方式，先进后出的方式； 递归在本质上就是一个栈结构，要实现反过来输出链表，在每次访问一个结点的时候，先递归输出他后面的结点，在输出该结点的本身  代码 import java.util.ArrayList; import java.util.Stack; /** * Created by haigeek on 2017/7/13. */ class ListNode{ int val; ListNode next=null; ListNode(int val){ this.val=val; } } //非递归的方式 public class Solution { public ArrayList&amp;lt;Integer&amp;gt; printListFromTailToHead(ListNode listNode) { Stack&amp;lt;Integer&amp;gt;stack=new Stack&amp;lt;&amp;gt;(); while (listNode!=null){ stack.push(listNode.val); listNode=listNode.next; } ArrayList&amp;lt;Integer&amp;gt;list=new ArrayList&amp;lt;&amp;gt;(); while (!stack.isEmpty()){ list.add(stack.pop()); } return list; } } //递归的方式 public class Solution2{ public ArrayList&amp;lt;Integer&amp;gt; printListFromTailToHead(ListNode listNode) { ArrayList&amp;lt;Integer&amp;gt;list=new ArrayList&amp;lt;&amp;gt;(); if(listNode!</description>
    </item>
    
    <item>
      <title>data-structure-tree</title>
      <link>https://example.com/note/computerscience/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</link>
      <pubDate>Tue, 28 Nov 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/computerscience/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</guid>
      <description>非线性结构-树 树  树的定义   树有很多节点组成，最上面的结点称为树的根，结点拥有的直接子节点称为结点的度，度为0的结点称为叶子； 所有结点的最大值就是该树的度 一个结点的直接子节点称为它的孩子，相应的，该结点称为孩子的双亲，相同双亲的孩子称为兄弟 一个结点的祖先是从根到该结点的所经过的所有结点，一个结点下的所有结点称为该结点的子孙 树有层次之分，根记为第一层，依次类推，称为该树的深度，双亲在同一层的结点称为堂兄弟  二叉树 二叉树是一种常见的数据结构，它的特点是一个结点的直接子节点最多只能有两个，并且有左右之分
 在二叉树中有种常见的称为完全二叉树结构，它的特点是除最后一层外每一层的结点树为2^(i-1),最后一层的结点树若不满足2^(i-1),那么最后一层的结点是从左向右排列的 二叉树也有顺序存储和链式存储两种 线索二叉树：用结点空的指针域来指向他的前驱或者后继结点，不浪费空的指针域  树的遍历  前序遍历：先访问根节点。再访问左子节点，最后访问右子节点 中序遍历：先访问左子节点，再访问根节点，最后访问右子节点 后序遍历：先访问左子节点，在访问右子节点，最后访问根节点 宽度优先遍历：一层一层访问，在同一层中，按照从左到右的顺序打印  堆 堆是一种经过排序的完全二叉树，其中任一非叶子节点的值均不大于（或不小于）其左孩子和右孩子节点的值。最大堆和最小堆是二叉堆的两种形式。
最大堆：根节点的键值是所有堆结点键值中最大者；最小堆：根节点的键值是所有堆结点键值中最小者；
最大-最小堆集结了最大最小堆的优点，最大-最小堆是最大层和最小层交替出现的二叉树，即最大层结点的儿子属于最小层，最小层结点的儿子属于最大层。
 最小堆   最大堆  二叉排序树 二叉排序树又叫二叉查找树，主要用于查找，或是一颗空树，或者是具有下列性质的二叉树
 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于它的根结点的值； 左、右子树也分别为二叉排序树；  哈夫曼树 哈夫曼树也成最优二叉树，它是带权路径长度最小的二叉树
哈夫曼的构造步骤如下：
假设有n个权值，则构造的哈夫曼树有n个叶子节点。n个权值分别为
 ​  </description>
    </item>
    
    <item>
      <title>Oracle常见函数</title>
      <link>https://example.com/note/database/oracle/oracle%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 27 Nov 2017 22:03:05 +0800</pubDate>
      
      <guid>https://example.com/note/database/oracle/oracle%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/</guid>
      <description>Oracle常见函数 单行函数 字符函数   LOWER函数和UPPER函数：
作用：将字符串转换为大/小写的格式
  length(char):
作用：返回字符串的长度
  initcap函数：
作用：将字符串中每个单词转换为首字母大写，其余字符小写
  ASCII函数和CHR函数
作用：字符和ascii码相互转换
  substr(char,m,n):
作用：截取字符串的子串，n代表n个字符的意思，不是代表取到第n个
  replace(char1, search_string, replace_string)
作用:替换函数
  instr(c1,c2,i,j)：
作用：判断某字符或者字符串是否存在，存在返回出现位置的索引，否则返回小于1；在一个字符串中搜索指定的字符，返回发现指定的字符的位置；C1 被搜索的字符串，C2希望搜索的字符串，I 搜索的开始位置，默认为1，J 出现的位置，默认为1
  select instr(&amp;#39;azhangsanbcd&amp;#39;, &amp;#39;zhangsan&amp;#39;) from dual; --返回2 select instr(&amp;#39;oracle traning&amp;#39;, &amp;#39;ra&amp;#39;, 1, 1) instring from dual; --返回2 select instr(&amp;#39;oracle traning&amp;#39;, &amp;#39;ra&amp;#39;, 1, 2) instring from dual; --返回9 select instr(&amp;#39;oracle traning&amp;#39;, &amp;#39;ra&amp;#39;, 1, 3) instring from dual; --返回0 select instr(&amp;#39;abc&amp;#39;,&amp;#39;d&amp;#39;) from dual; --返回0  LPAD函数和RPAD函数：</description>
    </item>
    
    <item>
      <title>Linear table</title>
      <link>https://example.com/note/computerscience/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
      <pubDate>Thu, 28 Sep 2017 21:48:16 +0800</pubDate>
      
      <guid>https://example.com/note/computerscience/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid>
      <description>线性表 顺序存储结构 线性表是零个或者多个数据元素的有限序列
 数据长度与线性表的长度区别：数据表的长度可以是已经规定的；线性表的长度是随着线性表的插入和删除而变化 地址计算方法：线性表的定义是从1开始，而数组是从0开始，于是线性表的第i个元素要存储在数租下标为i-1的位置；线性表的第i+1 个数据的存储位置和第i个元素的存储位置满足：LOC（ai+1）=LOC（ai）+1；第i个数据元素的ai的存储位置可以由a1推算出： LOC（ai）=LOC（a1）+（i-1）*c  顺序存储结构的插入和删除  插入算法思路  如果插入位置不合理，抛出异常 如果线性表长度大于或者等于数组的长度，抛出异常或者动态增加容量 从最后一个元素开始向前遍历到第i个位置，分别将他们都向后移动一个元素 将要插入元素填入位置i处 表长加1   复杂度 顺序存储结构在读，存数据的时候，复杂度为O(1)；插入或者删除的时候，时间复杂度为O(n) 优缺点：  优点：无需为表中元素之间的逻辑关系而增加额外的空间；可以快速地存取表中任意一位置的元素 缺点：插入和删除需要操作大量的元素；当线性表的长度变化较大时，难以确定存储空间的容量 容易造成存储空间的碎片化    线性表的链式存储结构 typedof struct Node { ElemType data; struct Node *next; }Node;*LinkList  假设L是LinkList型的变量，则L为单链表的头指针。它指向表中的第一个结点； 假设p是指向线性表中的第i个数据元素的指针，则p-&amp;gt;next是指向第i+1个数据元素的指针  单链表的整表创建 单链表整表的创建思路
 声明一结点和计数器变量i 初始化一空链表L； 让L的头结点的指针指向NULL，即建立一个头结点的单链表； 循环：  生成一新节点赋值给P； 随机生成一数字赋值给p的数据域p-&amp;gt;data； 将p插入到头结点与前一新结点之间    </description>
    </item>
    
    <item>
      <title>Oracle用户角色权限</title>
      <link>https://example.com/note/database/oracle/oracle%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90/</link>
      <pubDate>Wed, 27 Sep 2017 22:03:05 +0800</pubDate>
      
      <guid>https://example.com/note/database/oracle/oracle%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90/</guid>
      <description>Oracle用户角色权限 Oracle用户管理 创建用户
create user username identified by password default tablespace tablespace temporary tablespace tablespace profile profile 查询用户
select username, default_tablespace, temporary_tablespace from dba_users;--查询用户默认表空间，临时表空间 select * from dba_profiles;--查询系统资源文件名 创建用户的profile文件
 create profile student limit // student为资源文件名 FAILED_LOGIN_ATTEMPTS 3 //指定锁定用户的登录失败次数 PASSWORD_LOCK_TIME 5 //指定用户被锁定天数 PASSWORD_LIFE_TIME 30 //指定口令可用天数 修改用户
1、修改口令字： SQL&amp;gt;Alter user acc01 identified by &amp;quot;12345&amp;quot;; 2、修改用户缺省表空间： SQL&amp;gt; Alter user acc01 default tablespace users; 3、修改用户临时表空间 SQL&amp;gt; Alter user acc01 temporary tablespace temp_data; 4、强制用户修改口令字： SQL&amp;gt; Alter user acc01 password expire; 5、将用户加锁 SQL&amp;gt; Alter user acc01 account lock; // 加锁 SQL&amp;gt; Alter user acc01 account unlock; // 解锁 监视用户</description>
    </item>
    
    <item>
      <title>web程序运行机制与HTTP基础</title>
      <link>https://example.com/note/web/web%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8Ehttp%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 08 Mar 2017 16:25:16 +0000</pubDate>
      
      <guid>https://example.com/note/web/web%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8Ehttp%E5%9F%BA%E7%A1%80/</guid>
      <description>web程序运行机制与HTTP基础 web程序运行的过程  用户在客户端浏览器出入url地址，通过浏览器发出web请求 域名服务器对url地址进行解析，并和web服务器建立连接 web请求数据被浏览器封装为http报文，并传送到web服务器 web服务器在获取web请求后，根据请求信息，执行相关服务器代码（可能会访问后台服务器，数据库服务器），并将执行结构以html页面的方式返回给客户端 客户端将html页面代码在浏览器结解释执行  HTTP http是一种无状态的网络协议，默认端口为80.无状态是指每一次连接完成后，服务器无法识别上次进行连接的是哪个客户端的哪个程序.http协议传递的报文包括请求报文和响应报文 报文的格式有三部分组成：进行描述的起始行、包含属性的首部块、可选的额包含数据的主体
  http请求报文
http请求报文的格式如下: HTTP方法 请求的url HTTP版本 若干请求首部 空行 请求体
  一个典型的HTTP请求
  GET /index.jsp?param=void HTTP/1.1 Host:www.baidu.com Accept:text/*  http常用请求方法     方法 功能     GET 返回指定文档的内容   POST 利用附带的数据执行指定的文档   PUT 利用附带的数据替换指定的文档   DELETE 删除指定的文档   HEAD 返回指定文档的头信息   HTTP中最常用的是GET和POST方法    GET方法将参数形成字符串。然后附加在url后传输，参数串作为url的一部分出现在http请求的第一行，其中参数字符串以“？”开头参数以“key=value”的键值对的方式显示，每个键值对之间以“&amp;amp;”字符连接    POST方法先将url直接发出，消息头中不在含有参数，参数形成的字符串将被放在http消息体中发送。若发送html表单数据或者处于安全的考虑，应该使用这种方式      http响应报文</description>
    </item>
    
    <item>
      <title>mybatis笔记</title>
      <link>https://example.com/note/java/javaweb/mybaits/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Fri, 01 Jul 2016 22:21:02 +0800</pubDate>
      
      <guid>https://example.com/note/java/javaweb/mybaits/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>mybatis学习笔记（一） mybatis框架 操作流程  SqlMapConfig.xml(mybatis的全局配置文件)，配置数据源，事务等mybatis运行环境，配置映射文件（配置sql语句）mapper.xml（映射文件） SQLSessionFactory（会话工厂） 作用：创建SQLSession SQLSession（会话） 作用 操作数据库（发出sql 增删改查） Executor（执行器） SqlSession内部通过执行器操作数据库 mapped statement（底层封装对象） 对数据库存储封装，包括sql语句，输入参数、输出结果类型  </description>
    </item>
    
    <item>
      <title>Hibernate笔记</title>
      <link>https://example.com/note/java/javaweb/hibernate/hibernate%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 01 Jun 2016 22:21:02 +0800</pubDate>
      
      <guid>https://example.com/note/java/javaweb/hibernate/hibernate%E7%AC%94%E8%AE%B0/</guid>
      <description>Hibernate笔记 搭建Hibernate环境  导入jar包 创建实体类  使用Hibernate的时候，不需要手动创建表，Hibernate帮我们创建表   配置实体类和数据库表的一一对应关系 使用配置文件实现映射关系  创建xml格式的配置文件，映射配置文件名称和位置没有固定要求，建议在实体类所在的包创建，实体类名称.hbm.xml 配置是xml格式，在配置文件引进xml约束 配置映射关系  &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE hibernate-mapping PUBLIC &amp;#34;-//Hibernate/Hibernate Mapping DTD 3.0//EN&amp;#34; &amp;#34;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&amp;#34;&amp;gt; &amp;lt;hibernate-mapping&amp;gt; &amp;lt;!-- 配置类和表对应 name属性：实体类的全路径 table属性：数据库的名称--&amp;gt; &amp;lt;class name=&amp;#34;cn.haigeek.entity.User&amp;#34; table=&amp;#34;t_user&amp;#34;&amp;gt; &amp;lt;!-- 配置实体类id和表id hibernate要求实体类有一个属性唯一值 hibernate要求表有字段作为唯一值 --&amp;gt; &amp;lt;!-- id标签 name属性： 实体类里面id属性名称 column属性：生成表的字段名称 --&amp;gt; &amp;lt;id name=&amp;#34;uid&amp;#34; column=&amp;#34;uid&amp;#34;&amp;gt; &amp;lt;!-- 数据库表id主键字段增长 --&amp;gt; &amp;lt;generator class=&amp;#34;native&amp;#34;&amp;gt;&amp;lt;/generator&amp;gt; &amp;lt;/id&amp;gt; &amp;lt;!-- 配置其他属性和表字段对应 --&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; column=&amp;#34;username&amp;#34;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; column=&amp;#34;password&amp;#34;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;address&amp;#34; column=&amp;#34;address&amp;#34;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;/class&amp;gt; &amp;lt;/hibernate-mapping&amp;gt; 4. 创建hibernate的核心文件 - 文件格式xml；位置src下，名称hibernate.</description>
    </item>
    
    <item>
      <title>什么是hibernate</title>
      <link>https://example.com/note/java/javaweb/hibernate/hibernate%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 01 Jun 2016 22:21:02 +0800</pubDate>
      
      <guid>https://example.com/note/java/javaweb/hibernate/hibernate%E5%9F%BA%E7%A1%80/</guid>
      <description>Hibernate基础知识 什么是Hibernate Hibernate是一种ORM框架（OBject/Relational Mapping）；ORM意为对象关系映射，因此Hibernate会在java对象和关系数据库之间建立某种映射，以达到存取java对象的目的，是实现持久化存储（将内存中的数据存储在关系型的数据库、磁盘文件、XML数据文件中等等）的一种解决方案。
Hibernate 不仅管理 Java 类到数据库表的映射（包括从 Java 数据类型到 SQL 数据类型的映射），还提供数据查询和获取数据的方法，可以大幅度减少开发时人工使用 SQL 和 JDBC 处理数据的时间。这正是它的设计目标，即将软件开发人员从大量相同的数据持久层相关编程工作中解放出来。
什么是orm思想  让实体类和数据库表一一对应关系  让实体类和数据库表进行一一对应关系 让实体类属性和表里面的字段对应   不需要操作数据库表，而操作表对应实体类对象  Hibernate体系结构 从上图可以看出，HIbernate使用使用数据库和配置信息（Hibernate.properties)来为应用程序提供持久化服务（以及持久对象的Persistent OBjects）
 轻型的体系结构方案 要求应用程序提供自己的JDBC连接并管理自己的事务，这种方案使用了Hibernate API 的最小集：  全面解决的体系结构方案 将应用底层的JDBC/JTA API 中抽象出来，让Hibernate来处理这些细节   基本APIs  SessionFactory 对于单个数据库映射关系经过编译后的内存缓存，他是线程安全且不可变的。是session生成的工厂实例，也是ConnectProvider的一个客户端（会用到ConnectionProvider）。他在进程或集群的级别上，为那些在事务之前可重复使用的数据提供了选择性的二级缓存 Session 提供应用程序和持久化存储介质之间的一个单线程的会话对象，此对象生存期短，他隐藏了JDBC连接，也是Transaction的工厂实例，对于应用的持久化对象及其集合，他提供了一个一级缓存；当遍历导航对象图或者根据持久化标识查找对象时，会用到这个一级缓存  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/devops/jenkins/jenkins%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/devops/jenkins/jenkins%E5%AE%89%E8%A3%85/</guid>
      <description>Jenkins入门 安装 windows 启动jenkins环境的准备
˜启动方式war启动并需要支持端˜口修改
安装时推荐的插件不了解的可以全部安装，熟悉的可以根据需要安装
可能遇到的问题有
出现代理错误什么的 修改插件中心地址？一般百度都可以解决
Linux 使用rpm进行安装(选择合适的版本进行安装)
wget https://pkg.jenkins.io/redhat/jenkins-2.156-1.1.noarch.rpm rpm -ivh jenkins-2.156-1.1.noarch.rpm 修改目录权限
chown -R root:root /var/lib/jenkins chown -R root:root /var/cache/jenkins chown -R root:root /var/log/jenkins 启动
service start jenkins 在启动的时候可能会出现Java路径找不到的情况,设置一个软连接即可
ln -s /usr/java/jdk1.8.0_201/bin/java /usr/bin/java 设置编译环境 jdk、git、maven等
安装插件 一般安装时提供的插件相对已经比较完善，选几个比较常用的介绍下
常用的插件
git等</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/devops/jenkins/jenkins%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/devops/jenkins/jenkins%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E9%A1%B9%E7%9B%AE/</guid>
      <description>Jenkins快速复制已经存在的项目 针对已经存在的项目，可以快速复制出来，创建新的任务
前提是需要200.39服务器可以访问目标部署服务器，假如不支持访问，需要先配置目标服务器，后续写配置方式（熟练的话5分钟可配置完成）。
具体步骤 1、创建任务 2、配置流水线 需要准备的数据有：
 服务器ip tomcat文件夹 gitlab仓库地址（明确分支）  修改描述
修改流水线脚本，注意不要直接复制我的下面样例流水线配置，直接从复制出来的修改即可。
主要做以下操作
1、修改ip地址和tomcat的webapps地址，这里有个需要有注意的地方，假如tomcat的地址不存在空格的话，可以直接修改相关配置即可。具体看注释1、2、3、4、5
2、假如tomcat存在空格（不存在的话忽略此条），处理相对麻烦（暂时未攻克），直接参考注释6（相当于直接拼接出scp命令），另外配置了这种方式，步骤1可以不配置
3、设置gitlab地址和分支（拉代码需要有凭证，可以在jenkins添加，添加后才有访问仓库权限，目前凭证：zhaohj也就是赵海杰可以访问仓库的才能正常拉），修改位置在注释7
4、设置打包命令和打包环境（如果复制的项目属于同类，基本不用改，确认下即可），修改在注释8，否则重新写打包命令。此处一定要明确部署采用什么环境，推荐先去服务器复制已经有的配置，然后修改代码的test配置，走test环境部署。
5、确认要发送的war包，同上（如果复制的项目属于同类，基本不用改，确认下即可），否则就修改为target要发送的war包，修改地方在注释9
6、全部修改完build测试，后续可以稳定使用
 pipeline { environment { // 部署远程主机ip地址,需要通过密钥的方式设置免密登录 //注释1 服务器ip remoteIp = &amp;quot;192.168.1.196&amp;quot; //注释2 服务器登录用户 remoteName = &amp;quot;administrator&amp;quot; //注释3 服务器ssh端口 remotePort=&#39;22&#39; // 远程tomcat位置(使用/来表示路径) //注释4 tomcat安装位置 tomcatPath = &amp;quot;D:/GT/Tomcat_zj&amp;quot; //注释5 tomcat所在磁盘 tomcatPathDisk = &amp;quot;D:&amp;quot; } agent any tools { maven &#39;maven-3.6.1&#39; } stages { stage(&#39;pullcode&#39;){ steps{ //注释7 git branch: &#39;dev&#39;, credentialsId: &#39;zhaohjgitlab&#39;, url: &#39;http://elb-791125809.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/devops/jenkins/jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%BF%9C%E7%A8%8Bwindows%E4%B8%BB%E6%9C%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/devops/jenkins/jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%BF%9C%E7%A8%8Bwindows%E4%B8%BB%E6%9C%BA/</guid>
      <description>Jenkins部署项目到远程windows 使用ssh进行jenkins主节点与目标部署服务器进行通信,文件传输走scp协议,执行执行使用ssh命令远程到目标主机进行执行.
ssh调用命令脚本 使用ssh命令远程服务器进行脚本调用的时候的流程是:
 在本级ssh到目标主机 调用目标主机的脚本启动tomcat,假如我们调用的是bin目录下startup.bat 本机的终端窗口有输出,远程主机的tomcat启动成功 关闭本级的ssh终端 远程的tomcat随之关闭  要解决的问题 ssh调用的进程的生命周期问题 查阅资料发现
针对上述情况在linux下的解决方案很多,这里描述下winsows的解决方案.
在这个回答下,采取了将tomcat做成Windows服务的方式,问题得到解决,具体的配置方式如下:
设置tomcat的环境变量 下载安装版的Windows版tomcat,在bin目录下分别为server.bat、startup.bat、shutdown.bat设置环境变量,如下所示
将tomcat注册为服务 进入bin文件夹下执行
service install 服务名称
服务的启动与停止 net stop server-name net start server-name 将这两条指令做成bat脚本,放在bin目录下,供之后jenkins直接调用.
jenkins的终端输出乱码 在linux下远程调用Windows的终端的时候,在jenksin的控制台总是乱码.查阅资料多数是说设置Jenkins的编码为U8,但是我安装的jenkins本身设置就是U8,后来发现在远程调用的bat脚本第一行设置为
chcp 65001 表示切换到utf-8模式即可,之后输出默认为英文且不会再乱码.
是否有必要每次重启Tomcat 场景 在实际使用的过程中,每次部署假如都需要重启tomcat的话使得整个系统变得不稳定,那么是否每次更新都要重启tomcat呢?
首先我描述一下我遇到的一个问题,在jenkins中设置了一个重启tomcat的脚本,脚本如下:
pipeline { environment { // 部署远程主机ip地址,需要通过密钥的方式设置免密登录 remoteIp = &amp;quot;127.0.0.1&amp;quot; remotePort=&#39;22&#39; // 失败通知Email email = &amp;quot;test@haigeek.cn&amp;quot; // 远程tomcat位置(windows要使用/来表示路径) tomcatPath = &amp;quot;E:/tomcat/apache-tomcat-8.5&amp;quot; tomcatPathDisk = &amp;quot;E:&amp;quot; } agent any tools { maven &#39;maven-3.6.1&#39; } stages { stage(&#39;Deploy&#39;) { steps { withEnv([&#39;JENKINS_NODE_COOKIE=dontKillMe&#39;]) { sh &#39;&#39;&#39; export BUILD_ID=dontKillMe echo &amp;quot;开始使用scp传输文件&amp;quot; echo &amp;quot;开始调用远程tomcat进行重启&amp;quot; ssh -p ${remotePort} administrator@${remoteIp} &amp;quot;cd ${tomcatPath}/bin &amp;amp;&amp;amp; ${tomcatPathDisk} &amp;amp;&amp;amp; restart&amp;quot; &#39;&#39;&#39; } } } } } 上面的脚本核心功能就是调用远程tomca下的restart脚本来重启动tomcat,因为使用net stop tomcat 来关闭tomcat需要比较长时间,加上我们tomcat上运行的是dubbo项目,因此我直接使用taskkill的方式,根据dubbo端口来杀进程,结论是每次都可以成功杀死进程并重启tomcat,如下图,kill的脚本如下:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/devops/windowsserver%E5%AE%89%E8%A3%85openssh%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/devops/windowsserver%E5%AE%89%E8%A3%85openssh%E6%9C%8D%E5%8A%A1/</guid>
      <description>WindowsServer安装OpenSSH服务 下载 下载安装包
下载地址：https://github.com/PowerShell/Win32-OpenSSH/releases
解压到指定位置,推荐解压到C:\Program Files\OpenSSH64
安装  官方文档:https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH
 使用cmd进行安装,cd到安装位置,输入命令
powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1 开启防火墙 打开22端口
启动服务 net stat sshd
直接使用命令即可登录,例如
ssh administrator@192.168.1.1</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/devops/windows%E4%B8%8B%E5%AE%89%E8%A3%85openssh%E5%AE%9E%E7%8E%B0ssh%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/devops/windows%E4%B8%8B%E5%AE%89%E8%A3%85openssh%E5%AE%9E%E7%8E%B0ssh%E8%BF%9E%E6%8E%A5/</guid>
      <description>Windows下安装openssh实现ssh连接 下载 使用微软开源的openssh
下载地址: https://github.com/PowerShell/openssh-portable
安装 按照官网的说明安装openssh即可,官网说明:https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH
1、cd到安装目录,执行下面的命令
注意:openssh文件夹需要在C:\Program Files下
powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1 安装成功界面
2、开放防火墙端口,可以在winsows控制面板开启,也可以使用命令开启,默认端口为22
winsowsServer2012指令:
New-NetFirewallRule -Name sshd -DisplayName &#39;OpenSSH Server (sshd)&#39; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22 Windows10或者WindowsServer2008
netsh advfirewall firewall add rule name=sshd dir=in action=allow protocol=TCP localport=22 3、启动服务
net start sshd 4、设置开机自启动
Set-Service sshd -StartupType Automatic 5、使用用户名密码进行连接
配置密钥免登录 1、进入c盘下的user目录,找到当前用户的目录,一般是administrator
mkdir .ssh 进入到ssh目录下
# 新建一个txt文件,将服务器公钥粘贴进去 notepad authorized_keys # 重命名 mv authorized_keys.txt authorized_keys 2、修改ssh 服务的配置文件</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/devops/%E5%85%B3%E4%BA%8Edevops%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/devops/%E5%85%B3%E4%BA%8Edevops%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E5%BB%BA%E8%AE%AE/</guid>
      <description>devops 系统开发阶段 Junit单元测试 开发人员在开发时针对复杂接口或者容易出错的接口及时编写单元测试样例，可以提升代码稳定性，方便后续开发人员快速上手。
在线单元测试 yapi具有保存单元测试的功能，可以保存单元测试样例数据，优点在于具有可视化界面，多位开发人员可以维护一组测试数据，变更记录可查。
支持私有化部署。
系统部署阶段 jenkins自动化部署 部署方式 可以使用单jenkins支撑多系统部署，或者多节点的方式，实现一处平台搭建，服务多个项目的目的。
部署通知机制 部署前后可以借助企业微信机器人进行通知，方便测试人员和开发人员知晓部署动作。
系统配置修改 在使用docker之后，配置文件的修改会变得比较麻烦
使用apollo全局配置中心可以解决几个问题：
 配置项有更清晰易懂的说明。 在线对配置文件进行管理，部署包不再放配置文件，方便开发人员配置，实施人员查找，配置文件修改记录可查 部分配置可以实时生效 多环境配置时，配置的发布需要确认后才能发布，配置文件可回滚。实施人员可根据实际情况参与配置文件的修改，由开发人员进行确认即可。  系统运维监控三大件 系统运维监控三大件
 Log trace Metrics 基于目前现有的技术栈，可以从以下几个方面构建运维体系  SpringBoot SpringBoot Actuator SpringBoo借助Spring Boot Actuatort可以实现对系统的运行监控有良好的支持，但是Spring Boot Actuator暴露出的rest接口不方便数据的可视化。
较为高级的运维管理平台（基于Prometheus和Grafana）对SpringBoot Actuator也有支持。
springBoot-admin Spring Boot Admin 是一个管理和监控Spring Boot 应用程序的开源软件。每个应用都认为是一个客户端，通过HTTP或者使用 Eureka注册到admin server中进行展示，Spring Boot Admin UI部分使用AngularJs将数据展示在前端。
可以监控的数据有：
 应用基础信息 应用jvm相关的详细信息 应用运行环境信息以及应用的配置文件信息 日志文件/日志输出级别配置 jmx查看 应用实时线程信息 应用接口调用记录 对运行的系统进行headdump  1.x版本
2.x版本
dubbo dubbo-monitor
dubbo可以查看已经启动的消费者与提供者接口信息，主要统计以下信息
 接口/方法调用次数 接口/方法调用成功/失败率 接口/方法调用耗时 消费者与提供者的依赖情况  jvm 服务器的jvm监控有助于我们分析Java程序的运行健康度</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/docker/docker%E4%B8%AD%E7%9A%84oracle%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/docker/docker%E4%B8%AD%E7%9A%84oracle%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/</guid>
      <description># 启动docker并建立映射关系（此步骤不用做了） sudo docker run -d -p 1521:1521 -p 10022:22 --name=oracle11g -v ~/oracleData:/oracleData filemon/oracle_11g # 进入容器中（docker ps命令查看容器中oracle的containerid） sudo docker exec -it 容器ID /bin/bash # 配置系统环境变量（此步骤不用做了） $ vi ~/.bash_profile export ORACLE_SID=orcl export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2 export PATH=$ORACLE_HOME/bin:$PATH # 加载环境变量 source /home/oracle/.bash_profile # sys登陆oracle sqlplus sys/sys as sysdba # 删除用户(可选) drop user jhyzt cascade # 修改密码 alter user dgpnr_dis identified by pass alter user dgpnr_dis_oms identified by dgpnr_dis_oms # 删除表空间(可选) drop tablespace dgpims including contents and datafiles cascade constraint; # 创建表空间 create tablespace dgpnr_ims logging datafile &#39;/oracleData/dgpnr_ims.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/docker/docker%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/docker/docker%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83/</guid>
      <description>docker 安装基本环境 在安装环境的时候需要考虑宿主机与容器的网络通信问题
同一台主机上的docker容器默认的网段是相同的，容器之间是可以互相通信的，但是每次容器启动后的ip会按照网段的ip自动获取
zookeeper
docker -p 2181:2181 192.168.1.2:2181 2181
mongo
-p
oracle
-p
安装nginx 本地启动
docker run --name nginx -p 8079:80 -v /Users/haigeek/software/docker/nginx/www:/usr/share/nginx/html -v /Users/haigeek/software/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /Users/haigeek/software/docker/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf --privileged=true nginx 服务器配置
docker run --name nginx -p 8079:80 -v /usr/local/nginx/www:/usr/share/nginx/html -v /usr/local/nginx/conf/nginx.conf:/etc/nginx/nginx.conf --privileged=true nginx 启动第二个
docker run --name nginx2 -p 8080:80 -v /usr/local/nginx/nginx2/www:/usr/share/nginx/html -v /usr/local/nginx/nginx2/conf/nginx.conf:/etc/nginx/nginx.conf --privileged=true nginx 安装oracle
docker run -d -v /Users/haigeek/software/docker/oracleData:/data/oracle_data -p 1521:1521 wnameless/oracle-xe-11g
docker run --name oracle11g -d -v /usr/software/oradata:/oradata -p 1521:1521 -e ORACLE_ALLOW_REMOTE=true registry.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/docker/docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/docker/docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
      <description>docker容器的操作 启动 启动容器有两种方式，一个是基于镜像新建一个容器启动，另外一个是将终止状态的容器重新启动
新建并启动 使用 docker run 命令来启动容器 下面的代码是输出一个hello world然后终止容器
[root@VM_13_213_centos ~]# docker run ubuntu:16.04 /bin/echo &amp;#39;hello word&amp;#39; hello word 下面的命令则是则启动一个 bash 终端，允许用户进行交互，就像打开了Ubuntu系统
[root@VM_13_213_centos ~]# docker run -t -i ubuntu:16.04 /bin/bash root@d2499c769aea:/# 其中， -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i则让容器的标准输入保持打开。
命名 &amp;ndash;name 名称
端口映射 当docker启动的时候，可以是使用-P和-p进行端口的映射，将内部的端口映射出来
-P 随机映射
-p 指定端口映射 宿主机：容器端口
docker run -d -p 8080:8080 c8d8d44b57ad ##将内部的8080映射为宿主机的8080 数据卷映射 容器运行时应该尽量保持容器存储层不发生写操作。但是，有时候我们需要存储持久化的数据，比如数据库，你的数据都在容器中，肯定是不行的，因为一退出就没有了。
这个时候需要用到数据卷。数据卷就是可以让你把主机上的数据以挂载的方式链接到容器中，这样不同的容器也能共享，而且数据也不会因为容器的退出而丢失。
使用-v进行文件卷的映射
docker run -d -v ~/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs -d nginx #	将宿主机中当前目录下的www挂载到容器的/www、conf、wwwlogs类比 后台运行 -d 参数可以使得docker在后台运行 在不使用-d参数的时候，容器会将输出结果直接打印在宿主机上面 使用-d 参数运行容器将不会将输出进行打印，而是需要用户使用 docker container logs[container id or names]来查看输出</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/docker/docker%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/docker/docker%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C/</guid>
      <description>Docker容器的网络 Docker的网络模式 使用 docker network ls 可以查看docker的网络模式
docker目前支持以下5种网络模式：
 bridge：默认网络驱动程序。如果未指定驱动程序，则这是您要创建的网络类型。**当您的应用程序在需要通信的独立容器中运行时，通常会使用桥接网络。**查看 桥接网络。 host：对于独立容器，删除容器和Docker主机之间的网络隔离，并直接使用主机的网络。host 仅适用于Docker 17.06及更高版本的swarm服务。请参阅 使用主机网络。 overlay：覆盖网络将多个Docker守护程序连接在一起，并使群集服务能够相互通信。您还可以使用覆盖网络来促进群集服务和独立容器之间的通信，或者在不同Docker守护程序上的两个独立容器之间进行通信。此策略消除了在这些容器之间执行OS级别路由的需要。请参阅覆盖网络。 macvlan：Macvlan网络允许您为容器分配MAC地址，使其显示为网络上的物理设备。Docker守护程序通过其MAC地址将流量路由到容器。macvlan 在处理期望直接连接到物理网络的传统应用程序时，使用驱动程序有时是最佳选择，而不是通过Docker主机的网络堆栈进行路由。见 Macvlan网络。 none：对于此容器，禁用所有网络。通常与自定义网络驱动程序一起使用。none不适用于群组服务。请参阅 禁用容器网络。  默认是桥接模式，网络地址为172.17.0.0/16，同一主机的容器实例能够通信，但不能跨主机通信。
host模式 如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。
container模式 这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。
none模式 这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。
bridge模式 bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/docker/docker%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E4%B8%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/docker/docker%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E4%B8%80/</guid>
      <description>docker知识学习（一） Docker简介与安装 1、简介 Docker是一个开源的应用容器引擎；是一个轻量级容器技术；
Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；
运行中的这个镜像称为容器，容器启动是非常快速的。
2、核心概念 docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；
docker客户端(Client)：连接docker主机进行操作；
docker仓库(Registry)：用来保存各种打包好的软件镜像；
docker镜像(Images)：软件打包好的镜像；放在docker仓库中；
docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用
3、Docker的安装与卸载 安装步骤： 1、检查内核版本，必须是3.10及以上
uname -r 2、安装docker
yum install docker 3、输入y确认安装
4、启动docker
[root@localhost ~]# systemctl start docker [root@localhost ~]# docker -v Docker version1.12.6, build 3e8e77d/1.12.6 5、开机启动docker
[root@localhost ~]# systemctl enable docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 6、停止docker
systemctl stop docker 卸载步骤： 1首先搜索已经安装的docker 安装包
[root@localhost ~]# yum list installed|grep docker 或者使用该命令
[root@localhost ~]# rpm -qa|grep docker docker.x86_64 2:1.12.6-16.el7.centos @extras docker-client.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/docker/docker%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/docker/docker%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</guid>
      <description>Docker简介与安装 Docker是一个开源的应用容器引擎；是一个轻量级容器技术；
1、简介 Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；运行中的这个镜像称为容器，容器启动是非常快速的。
2、docker的优点 更轻量镜像尺寸小 ，资源利用率高 。我们方便去牵引，牵引的话如果已经有一些镜像存在的话，镜像尺寸就比较小。同时因为它没有虚拟机那么重，所以它的健壮率会很高。更快速直接运行在宿主机上，没有IO转换负担。它就是宿主机上的一个进程，启一个进程是非常快的，没有像虚拟机还要进行CPU，内存的这些时间的消耗，并且docker它利用率高也体现。更便捷易安装，易使用，迁移方便，数据量小。安装docker就通过一个命令，一个脚本就把docker装起来，也很方便去使用，我们只有熟悉docker的命令，我们就可以把它运用起来。迁移的时候，我们不要去迁移docker，我们去迁移的是容器的镜像，数据量小也体现在镜像的分层技术，同一批镜像，如果有很多个，它是重复的，它只会占用一个磁盘空间。 3、核心概念 docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；docker客户端(Client)：连接docker主机进行操作；docker仓库(Registry)：用来保存各种打包好的软件镜像；
docker镜像(Images)：软件打包好的镜像；放在docker仓库中；镜像不包含任何动态数据，其内容在构建之后也不会被改变。其中使用分层技术，当我们下载镜像时候，会根据每一层的镜像标识判断是否已经下载过，下载过的layer不会重复下载，一个镜像不能超过 127 层。docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用；镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。容器尽管可以运行多个服务，但推荐只运行一个服务。
上面的两张图展示了容器与镜像、镜像与宿主机的关系。容器是在镜像上加了一层可读写层来使得外界可以使用镜像。而这一切的基础都依赖于宿主机提供的系统和内核以及硬件支持。
4、Docker的安装与卸载 安装步骤： 1、检查内核版本，必须是3.10及以上uname -r
2、安装dockeryum install docker
3、输入y确认安装
4、启动docker
[root@localhost ~]# systemctl start docker
[root@localhost ~]# docker -vDocker version1.12.6, build 3e8e77d/1.12.6
5、开机启动docker[root@localhost ~]# systemctl enable docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
6、停止docker
systemctl stop docker
卸载步骤： 1首先搜索已经安装的docker 安装包[root@localhost ~]# yum list installed|grep docker或者使用该命令[root@localhost ~]# rpm -qa|grep dockerdocker.x86_64 2:1.12.6-16.el7.centos @extrasdocker-client.x86_64 2:1.12.6-16.el7.centos @extrasdocker-common.x86_64 2:1.12.6-16.el7.centos @extra2 分别删除安装包[root@localhost ~]#yum –y remove docker.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/docker/docker%E9%95%9C%E5%83%8F%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/docker/docker%E9%95%9C%E5%83%8F%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
      <description>docker镜像 镜像的操作命令 修改镜像源 对于使用 systemd 的系统（Ubuntu 16.04+、Debian 8+、CentOS 7）， 在配置文件 /etc/docker/daemon.json 中加入：
{ &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://docker.mirrors.ustc.edu.cn/&amp;quot;] } 重新启动 docker：
sudo systemctl restart docker 获取镜像 从docker仓库获取镜像
docker pull [Docker Registry 地址[:端口号]/] [仓库名]：[标签] Docker 镜像仓库地址：地址的格式一般是 &amp;lt;域名/IP&amp;gt;[:端口号]。默认地址是 Docker Hub。 仓库名：如之前所说，这里的仓库名是两段式名称，即 &amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。
例如：
 docker pull ubuntu:16.04 列出镜像 docker image ls 列出部分镜像
docker image ls ubuntu（仓库名） docker image ls ubuntu:16.04（仓库名:标签） docker image ls -f since=mongo:3.2（过滤器 在 mongo:3.2 之后建立的镜像） docker image ls -q（--filter 配合 -q 产生出指定范围的 ID 列表） 列出中间层镜像 为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/dubbo/dubbo-filter%E4%B8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/dubbo/dubbo-filter%E4%B8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>Dubbo filter下的异常处理 场景 现有的异常处理下,很多时候我们总是会遇到下面的这个异常
那就存在一个问题
我明明自己定义了自定义异常(继承自RuntimeException),在全局异常处理也做了对应的处理
但是并没有被处理.
分析 查看dubboFileter的ExceptionFilter发现:
抛出异常的代码在68行,查看上下文分析在什么时候会抛出这个异常
解决 那么我们想直接返回异常的message给到前端的时候,根据源码可以制定下面两种方式
1、使用非运行时异常Exception
检查型异常Exception按照常规的方式,在每一层(domain、seviceImpl、interface层)抛出Exception
但是要注意的是:在使用非运行时异常的时候,代码检查工具sonar推荐不要直接Throw Exception,而是抛出明确的异常来提升代码的可读性.
2、使用RunTimeException,但是只在接口层抛出即可
如下:
接口层
实现层,在实现层不需要专门抛出
效果:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/dubbo/dubbo%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E7%AB%AF%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/dubbo/dubbo%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E7%AB%AF%E5%8F%A3/</guid>
      <description>dubbo使用随机端口 随机端口生成方式 查看源码定位到dubbo获取端口的方法在doExportUrlsFor1Protocol
此方法中关于端口的代码如下：
//从dubbo:protocol标签中读取port配置 Integer port = protocolConfig.getPort(); //如果有provider标签配置，且protocol中port配置为null 或者 0，则直接使用provider中的port端口  if (this.provider != null &amp;amp;&amp;amp; (port == null || port == 0)) { port = this.provider.getPort(); } //根据协议类型获取默认端口号（默认端口为20880）  int defaultPort = ((Protocol)ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name)).getDefaultPort(); //如果配置port为null或者0，则会使用默认端口  if (port == null || port == 0) { port = defaultPort; } //如果配置port为null或者小于0（例如-1）则使用自动端口  if (port == null || port &amp;lt;= 0) { //获取随机端口，从缓存中取  port = getRandomPort(name); //如果获取端口为空，则以默认端口为基准，按顺序取最近一个可用的端口  if (port == null || port &amp;lt; 0) { port = NetUtils.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/dubbo/dubbo%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/dubbo/dubbo%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81/</guid>
      <description>Dubbo-参数验证 介绍 Dubbo中的参数验证基于JSR-303，它是JAVA EE 6中的一项子规范，通过注解的方式用来对 Java Bean中字段的值进行简单验证。Consumer端要调用Provider端的接口，调用接口的话就会有参数用于传递数据，这里的验证指的就是对这个参数进行验证
这个JSR基于注释的JavaBeanTM验证定义一个元数据模型和API，通过使用XML验证描述符覆盖和扩展元数据。
准备 &amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;javax.validation&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;validation-api&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.0.0.GA&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;4.2.0.Final&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;代码示例    参数验证主要在实体类和接口上进行设置
package com.dist.entity;import java.io.Serializable;import java.util.Date;import javax.validation.constraints.Future;import javax.validation.constraints.Max;import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;import javax.validation.constraints.Past;import javax.validation.constraints.Pattern;import javax.validation.constraints.Size;/*** demo* @author changzhi**/public class ValidationParameter implements Serializable {private static final long serialVersionUID = 1119411448459221069L;@NotNull // 不允许为空@Size(min = 2, max = 10) // 长度或大小范围private String name;@NotNull(groups = ValidationService.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/dubbo/dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/dubbo/dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
      <description>dubbo学习笔记 什么是dubbo dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案，dubbo是一个服务框架，在需要分布式的时候，需要使用dubbo这样的框架进行远程服务调用，dubbo采用全spring的配置，透明化接入应用，只需用Spring加载dubbo的配置即可。
dubbo包含什么  远程通讯 提供对多种基于长连接的NIO的框架的抽象封装，包括多种线程模型，序列化，以及请求-响应模式的信息交换模式 集群容错 在在集群调用失败时，Dubbo 提供了多种容错方案 自动发现 基于注册中心目录服务，使服务消费方能动态查找服务提供方，使地址透明，使服务提供方可以平滑增加或者减少机器  dubbo可以做什么  远程服务调用，通过简单的配置服务提供方和服务消费方，即可完成远程服务调用的配置，配置基于spring 软负载均衡及容错机制 服务的自动注册与发现，注册中心基于接口名查询服务提供服务提供者的ip地址，并且能够平滑添加或删除服务提供者。  dubbo的架构  Provider:暴露服务的服务提供方 Consumer：调用远程服务的服务消费方 Registry：服务注册与发现的注册中心 Monitor： 统计服务的调用次调和调用时间的监控中心 Container： 服务运行容器 调用关系说明：   服务提供者在启动时，向注册中心注册自己提供的服务 服务消费者在启动时，向注册中心订阅所需的服务 注册中心返回服务提供者列表给消费者，如有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/dubbo/dubbo%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/dubbo/dubbo%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</guid>
      <description>dubbo后台模块分析
dgp-server-mobile-api 这一模块主要是进行各种定义,供dgp-server-mobile-service这一模块进行调用，包括了常量的定义，数据实体的定义(与数据库中的表对应)，数据传输对象(服务层需要接收的数据和返回的数据),VO（展示层需要显示的数据）。定义service接口，在其他模块实现这些接口。
 constants 定义常量 dto(Data Transfer Object) 数据传输对象 vo(view object) 视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。 entity 数据实体，与数据库中的表对应 service 定义公共接口 但不在这一模块实现 pom文件 集成父pom文件，打包为jar包，引入依赖并排除不需要的依赖  dgp-server-mobile-service 这一模块在dubbo中担任提供者的角色，主要的业务处理逻辑在这一层得以实现，同时数据的存储也在这一模块实现。
包的定义及功能  主要代码部分   dao层主要处理与数据库相关的操作 domain层主要是业务逻辑的处理，通过dao层和数据库打交道 service层 业务接口的实现类，service层会调用domain层来进行数据的交互 manage层 存放管理类的代码 util存放工具类   assembly：包含打包成tar.gz文件的配置文件，并且需要maven-assembly-plugin插件 profiles：属性文件 resources：资源配置文件，在此处定义dubbo远程服务接口 pom文件 集成父pom文件；打包成jar包；添加相关的jar包： 引入dgp-server-mobile-api jar包 同时需要插件： maven-assembly-plugin maven-jar-plugin  dgp-server-mobile-web 这一模块在dubbo中担任消费者的角色，这一模块将整个系统的接口暴露出来供前端调用，Controller层调用service层来进行业务逻辑的处理
包的定义及功能  controller 提供服务到前端 swagger swagger相关 resources 配置文件，包括dubbo和spring的相关配置，在此处进行定义dubbo消费者的接口 webapp web.xml配置过滤以及监听  分级的意义
系统层面  前后端分离，通过restful来进行接口的设计，通过swagger来进行接口的管理，使得系统的接口简洁明了 通过dubbo来进行分布式的架构设计,消费者和提供者的通过注册中心来进行联系，建立稳定的服务中心，同时支持分布式部署，提升系统的稳定性和健壮性  开发层面  分层开发使得系统逻辑清晰，每一层都有不同的功能，将系统进行解耦，提升了系统的可拓展性，同时方便开发者快速定位问题。 较之前的三层业务模式，最直观的是层次更加清晰，当我们的业务越来越复杂的时候，原有的结构已经不能满足我们的需求，显得比较混乱，那么采用dubbo，将每个模块抽分出来（服务化），通过注册中心来维持整个架构的运转 新的架构降低了系统的耦合性，提升系统的拓展性，在增加一个功能时，只需要增加一个模块，调用其他模块的接口即可。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/dubbo/windows%E5%AE%89%E8%A3%85dubbo%E7%AE%A1%E6%8E%A7%E5%8F%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/dubbo/windows%E5%AE%89%E8%A3%85dubbo%E7%AE%A1%E6%8E%A7%E5%8F%B0/</guid>
      <description>windows安装dubbo管控台和dubbo监控中心 dubbo管控台 dubbo管控台介绍 注册中心zookeeper只是一个黑框，不能看到是否存在什么提供者和消费者，借助Dubbo-Admin管理平台进行实时的查看
dubbo的安装与配置  下载编译好的dubbo-admin的war包 复制war内的文件到tomcat webapps文件夹下的Root文件夹（要清空root文件夹下原本的文件），也可以不复制到root文件夹，访问是需要在url输入文件夹名称   获取war包内的文件有两种方式，一种方式为使用解压工具打开war包复制war的文件。另外一钟方式就是将war放在webapps文件夹下，启动tomcat，tomcat会自动解压得到同名文件夹，复制文件夹下的内容即可
 复制完成后，进入WEB-INF文件夹，修改dubbo.propreties文件  #zookeeper服务地址 dubbo.registry.address=zookeeper://127.0.0.1:2181 #root用户密码 dubbo.admin.root.password=root #guest用户密码 dubbo.admin.guest.password=guest dubbo管控的使用  启动zookeeper 启动tomcat 在浏览器输入localhost：8080进入dubbo管控中心  dubbo监控中心 什么是dubbo监控中心 监控中心是一个标准的dubbo服务，配置完成之后可以结合admin管理台使用，可以清晰看到服务的访问记录，成功次数，失败次数
安装与配置  下载编译好的dubbo-minitor-simple-2.5.3-assembly.tar.gz 解压文件，进入conf文件夹，编辑配置文件dubbo.propreties  ## # Copyright 1999-2011 Alibaba Group. # # Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/dubbo/zookeeper%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/dubbo/zookeeper%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>zookeeper注册中心的安装 什么是zookeeper zookeeper是一个开源的分布式协调服务，zookeeper的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，以一系列的简单易用的接口提供给用户使用，分布式应用程序可以基于他实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、分布式锁和分布式队列等功能
安装和配置   从官网下载压缩包后解压到本地
  在conf文件夹下存在一个名为zoo_simple.conf的配置文件，复制此配置文件并重新命名为zoo.conf即可，因为zookeeper在启动时需要在conf文件夹下寻找这个配置文件   修改zoo.conf的配置文件
  # The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/dubbo/zookeeper%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/dubbo/zookeeper%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88/</guid>
      <description>zookeeper未授权访问漏洞修复方案 zk的身份认证与权限 身份认证方式有四种：
world：默认方式，相当于全世界都能访问
auth：代表已经认证通过的用户(cli中可以通过addauth digest user:pwd 来添加当前上下文中的授权用户)
digest：即用户名:密码这种方式认证，这也是业务系统中最常用的
ip：使用Ip地址认证
对节点的操作权限有：
CREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这5种权限简写为crwda(即：每个单词的首字符缩写)
注：这5种权限中，delete是指对子节点的删除权限，其它4种权限指对自身节点的操作权限
zk配置 使用auth方式进行zk的认证
1、首先使用zkcli登录zk
# linux ./zkCli.sh # win zkCli.cmd 2、查找所有节点
ls / 输出结果为：
[spring-cloud-service, dubbo, services, zookeeper] 3、新增登录zk需要的用户名密码
addauth digest dist:pass 4、对节点分别进行授权（根据2查出来的列表）
setAcl /dubbo auth:dist:pass:rwadc setAcl /zookeeper auth:dist:pass:rwadc setAcl /spring-cloud-service auth:dist:pass:rwadc setAcl /services auth:dist:pass:rwadc 假如取消授权，使用下面命令 将节点（ 也需要是具体的节点）权限设置为world权限，并允许任何人进行acd操作
setAcl /dubbo world:anyone:acd dubbo应用配置 dubbo支持使用认证方式登录zk
在系统的dubbo配置xml中增加username和password即可
&amp;lt;dubbo:registry address=&amp;quot;${dubbo.registry.address}&amp;quot; file=&amp;quot;${dubbo.registry.file}&amp;quot; username=&amp;quot;dist&amp;quot; password=&amp;quot;pass&amp;quot;/&amp;gt; 假如dubbo中不增加相关配置 会报如下错误：
Caused by: org.I0Itec.zkclient.exception.ZkException: org.apache.zookeeper.KeeperException$NoAuthException: KeeperErrorCode = NoAuth for /dubbo/com.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/elk%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/elk%E6%90%AD%E5%BB%BA/</guid>
      <description>ELK搭建 环境搭建 ES 下载 wget https://artifacts.elastic.co/downloads/logstash/logstash-6.0.0.tar.gz
安装 Elasticsearch 不能使用 root 用户启动，因此需要添加新的用户：
useradd -d /usr/elk -m -s /bin/bash elk
将下载后的文件进行解压，配置文件进行配置
可能出现的问题 1、es的虚拟内存问题
ERROR: [2] bootstrap checks failed [1]: initial heap size [536870912] not equal to maximum heap size [1073741824]; this can cause resize pauses and prevents mlockall from locking the entire heap [2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 处理方式：
在/etc/sysctl.conf加上vm.max_map_count = 262144</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/centos%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/centos%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid>
      <description>Centos安装与配置 安装准备 镜像下载：http://mirrors.aliyun.com/centos/7/isos/x86_64/ (阿里云镜像仓库）
虚拟机 ：vm
ssh工具： xshell
安装 略
配置 在虚拟机配置独立的ip地址 先看一下本机的网关和 ip，例如：
ip 是： 192.168.2.126 网关是： 192.168.2.1 编辑centos的网卡配置文件
vi /etc/sysconfig/network-scripts/ifcfg-eth0 在网卡配置文件配置如下内容设置静态ip
BOOTPROTO=static # 网卡获取IP的方式(默认为dchp,设置为静态获取。 IPADDR=192.168.2.20 # 除最后部分其他与宿主机的网关一致 GATEWAY=192.168.2.1 # 与宿主机保持一致 NETMASK=255.255.255.0 如果要访问外网还要配置 DNS
DNS1=192.168.2.1 DNS2=8.8.8.8 配置完之后保存重启网络
service network restart 之后就可以通过ssh连接
ssh root@192.168.2.20 通过yum安装一些基本的文件 net-tools 提供dig, nslookup, ipconfig等，用于配置网络：
yum install net-tools 禁止root用户使用ssh登录（生产环境） 进入配置文件：
/etc/ssh/sshd_config 找到如下语句进行修改
PermitRootLogin yes 把它改成
PermitRootLogin no 重启 sshd
systemctl restart sshd.service </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid>
      <description>安装
$ yum install crontabs $ systemctl enable crond $ systemctl start crond 配置定时规则
vim /etc/crontab 保存定时规则
crontab /etc/crontab 查看任务
crontab -l </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%96%87%E4%BB%B6%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%96%87%E4%BB%B6%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;h1 id=&#34;omclinux常用命令文件认识与操作&#34;&gt;omclinux常用命令（文件认识与操作）&lt;/h1&gt;
&lt;h2 id=&#34;文件和属性目录&#34;&gt;文件和属性目录&lt;/h2&gt;
&lt;h4 id=&#34;linux目录结构&#34;&gt;linux目录结构&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录名称&lt;/th&gt;
&lt;th&gt;应放置文件的内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/boot&lt;/td&gt;
&lt;td&gt;开机所需文件—内核、开机菜单以及所需配置文件等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/dev&lt;/td&gt;
&lt;td&gt;以文件形式存放任何设备与接口，在Linux中访问设备的方式和访问文件的方式是相同的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/etc&lt;/td&gt;
&lt;td&gt;配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/home&lt;/td&gt;
&lt;td&gt;用户主目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/bin&lt;/td&gt;
&lt;td&gt;存放单用户模式下还可以操作的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/lib&lt;/td&gt;
&lt;td&gt;开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/sbin&lt;/td&gt;
&lt;td&gt;开机过程中需要的命令，s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/media&lt;/td&gt;
&lt;td&gt;用于挂载设备文件的目录，linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/opt&lt;/td&gt;
&lt;td&gt;放置第三方的软件，比如你安装一个ORACLE数据库则就可以放到这个目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/root&lt;/td&gt;
&lt;td&gt;系统管理员的家目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/srv&lt;/td&gt;
&lt;td&gt;该目录存放一些服务启动之后需要提取的数据，例如一些网络服务的数据文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/tmp&lt;/td&gt;
&lt;td&gt;任何人均可使用的“共享”临时目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/usr&lt;/td&gt;
&lt;td&gt;unix software resource 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/usr/local&lt;/td&gt;
&lt;td&gt;用户自行安装的软件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/usr/sbin&lt;/td&gt;
&lt;td&gt;Linux系统开机时不会使用到的软件/命令/脚本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/usr/share&lt;/td&gt;
&lt;td&gt;帮助与说明文件，也可放置共享文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/var&lt;/td&gt;
&lt;td&gt;主要存放经常变化的文件，如日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/proc&lt;/td&gt;
&lt;td&gt;虚拟文件系统，例如系统内核、进程、外部设备及网络状态等,它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/lost+found&lt;/td&gt;
&lt;td&gt;当文件系统发生错误时，将一些丢失的文件片段存放在这里&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/mnt&lt;/td&gt;
&lt;td&gt;系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/sys&lt;/td&gt;
&lt;td&gt;这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/etc&lt;/strong&gt;： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/bin, /sbin, /usr/bin, /usr/sbin&lt;/strong&gt;: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。&lt;/p&gt;
&lt;p&gt;值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/var&lt;/strong&gt;： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。&lt;/p&gt;
&lt;h4 id=&#34;linux文件类型与文件权限&#34;&gt;linux文件类型与文件权限&lt;/h4&gt;
&lt;p&gt;Linux文件类型常见的有：普通文件、目录文件、字符设备文件和块设备文件、符号链接文件等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当为[ &lt;strong&gt;d&lt;/strong&gt; ]则是目录&lt;/li&gt;
&lt;li&gt;当为[ &lt;strong&gt;-&lt;/strong&gt; ]则是文件；&lt;/li&gt;
&lt;li&gt;若是[ &lt;strong&gt;l&lt;/strong&gt; ]则表示为链接文档(link file)；&lt;/li&gt;
&lt;li&gt;若是[ &lt;strong&gt;b&lt;/strong&gt; ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；&lt;/li&gt;
&lt;li&gt;若是[ &lt;strong&gt;c&lt;/strong&gt; ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/006tKfTcly1g0v737k6kvj30gh039wee.jpg&#34; alt=&#34;文件权限&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;linux文件属性详解&#34;&gt;Linux文件属性详解&lt;/h4&gt;
&lt;p&gt;第一列：inode（inode 译成中文就是索引节点。每个存储设备或存储设备的分区（存储设备是硬盘、软盘、U盘等等）被格式化为文件系统后，应该有两部份，一部份是inode，另一部份是Block，Block是用来存储数据用的。而inode呢，就是用来存储这些数 据的信息，这些信息包括文件大小、属主、归属的用户组、读写权限等。inode为每个文件进行信息索引，所以就有了inode的数值。操作系统根据指令， 能通过inode值最快的找到相对应的文件）&lt;/p&gt;
&lt;p&gt;第二列：文件种类和权限；&lt;/p&gt;
&lt;p&gt;第三列： 硬链接个数；&lt;/p&gt;
&lt;p&gt;第四列： 属主；&lt;/p&gt;
&lt;p&gt;第五列：所归属的组；&lt;/p&gt;
&lt;p&gt;第六列：文件或目录的大小；&lt;/p&gt;
&lt;p&gt;第七列和第八列：最后访问或修改时间；&lt;/p&gt;
&lt;p&gt;第九列：文件名或目录名&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;【硬连接】
硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。&lt;/p&gt;
&lt;p&gt;【软连接】
另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文件目录操作命令&#34;&gt;文件目录操作命令&lt;/h2&gt;
&lt;h3 id=&#34;cd&#34;&gt;cd&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命令格式&lt;/strong&gt;：cd [目录名]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命令功能&lt;/strong&gt;：切换当前目录至dirName&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cd / 进入指定的路径&lt;/p&gt;
&lt;p&gt;cd .. 进入上一级，可以一直到跟目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ls&#34;&gt;ls&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;命令格式：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ls [选项] [目录名]&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;命令功能：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;列出目标目录中所有的子目录和文件。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;常用参数：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ls -a&lt;/td&gt;
&lt;td&gt;–all 列出目录下的所有文件，包括以 . 开头的隐含文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ls -c&lt;/td&gt;
&lt;td&gt;根据 ctime 排序及显示 ctime (文件状态最后更改的时间)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ls -l&lt;/td&gt;
&lt;td&gt;除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ls -R&lt;/td&gt;
&lt;td&gt;显示目录的子目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ls -t&lt;/td&gt;
&lt;td&gt;以文件修改时间排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ls -S&lt;/td&gt;
&lt;td&gt;根据文件大小排序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;pwd&#34;&gt;pwd&lt;/h3&gt;
&lt;p&gt;pwd 用于显示用户当前所处的工作目录&lt;/p&gt;
&lt;p&gt;目录连接链接时，pwd -P  显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径&lt;/p&gt;
&lt;h3 id=&#34;mkdir&#34;&gt;mkdir&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;命令格式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;mkdir [选项] 目录&amp;hellip;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;命令功能&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;命令参数&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-m, &amp;ndash;mode=模式，设定权限&amp;lt;模式&amp;gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask&lt;/p&gt;
&lt;p&gt;-p, &amp;ndash;parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;&lt;/p&gt;
&lt;p&gt;-v, &amp;ndash;verbose  每次创建新目录都显示信息&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mkdir test

mkdir -p test1/test2

mkdir -v test
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;rm&#34;&gt;rm&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;命令格式&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;rm [选项] 文件…&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;命令功能&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;命令参数&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    -f, &amp;ndash;force    忽略不存在的文件，从不给出提示。&lt;/p&gt;
&lt;p&gt;​    -i, &amp;ndash;interactive 进行交互式删除&lt;/p&gt;
&lt;p&gt;​    -r, -R, &amp;ndash;recursive   指示rm将参数中列出的全部目录和子目录均递归地删除。&lt;/p&gt;
&lt;p&gt;​    -v, &amp;ndash;verbose    详细显示进行的步骤&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;示例&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;rm 文件名

rm -f 文件名

rm -i *.txt

rm -r 文件夹

rm -rf 文件夹
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;rmdir&#34;&gt;rmdir&lt;/h4&gt;
&lt;p&gt;删除空目录,假如目录中还存有内容，不能删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm -p 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;连同上一级的空目录也删除&lt;/p&gt;
&lt;h3 id=&#34;mv&#34;&gt;mv&lt;/h3&gt;
&lt;p&gt;移动文件与目录，或修改名称&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;命令格式：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    mv [选项] 源文件或目录 目标文件或目录&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;命令功能&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;命令参数&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;-b ：若需覆盖文件，则覆盖前先行备份。&lt;/p&gt;
&lt;p&gt;-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；&lt;/p&gt;
&lt;p&gt;-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！&lt;/p&gt;
&lt;p&gt;-u ：若目标文件已经存在，且 source 比较新，才会更新(update)&lt;/p&gt;
&lt;p&gt;-t  ： &amp;ndash;target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;mv test.log test1.txt   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改文件名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv test1.txt test3    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将test1.txt文件移到目录test3中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv log1.txt log2.txt log3.txt test3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将文件log1.txt,log2.txt,log3.txt移动到目录test3中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv -t /opt/soft/test/test4/ log1.txt log2.txt log3.txt 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;log1.txt log2.txt log3.txt  移动到目录test4&lt;/p&gt;
&lt;p&gt;移动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv * ../ 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;移动当前文件夹下的所有文件到上一级目录&lt;/p&gt;
&lt;h3 id=&#34;cp&#34;&gt;cp&lt;/h3&gt;
&lt;p&gt;cp 即拷贝文件和目录。复制目录 目录存在与目录不存在的情况 目标目录存在时，整个源目录被复制到目标目录里面。&lt;/p&gt;
&lt;p&gt;选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**-a：**相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)&lt;/li&gt;
&lt;li&gt;**-d：**若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；&lt;/li&gt;
&lt;li&gt;**-f：**为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；&lt;/li&gt;
&lt;li&gt;**-i：**若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)&lt;/li&gt;
&lt;li&gt;**-l：**进行硬式连结(hard link)的连结档创建，而非复制文件本身；&lt;/li&gt;
&lt;li&gt;**-p：**连同文件的属性一起复制过去，而非使用默认属性(备份常用)；&lt;/li&gt;
&lt;li&gt;**-r：**递归持续复制，用於目录的复制行为；(常用)&lt;/li&gt;
&lt;li&gt;**-s：**复制成为符号连结档 (symbolic link)，亦即『捷径』文件；&lt;/li&gt;
&lt;li&gt;**-u：**若 destination 比 source 旧才升级 destination ！&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cp -a 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;复制后文件属性与原文件相同，类似于快捷方式 cp 会赋予一个新的操作时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp -i 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在遇到重名的文件时候，会给出提示&lt;/p&gt;
&lt;h3 id=&#34;文件创建与查看命令&#34;&gt;文件创建与查看命令&lt;/h3&gt;
&lt;h3 id=&#34;touch&#34;&gt;touch&lt;/h3&gt;
&lt;p&gt;新建一个文件，输入文件名和文件格式即可创建&lt;/p&gt;
&lt;h3 id=&#34;cattac&#34;&gt;cat/tac&lt;/h3&gt;
&lt;p&gt;cat由第一行开始显示文件内容  tac从最后一行开始显示，可以看出 tac 是 cat 的倒著写！&lt;/p&gt;
&lt;h3 id=&#34;nl&#34;&gt;nl&lt;/h3&gt;
&lt;p&gt;查看文件并显示行号&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/</guid>
      <description>linux常用命令（文件查找、文件下载、文件压缩、用户、权限） 文件查找命令 which 查看可执行文件的位置
whereis 查看文件的位置
find 实际搜寻硬盘查询文件名称
find / -name Redis-x64-3.2.100.zip 文件下载 wget 安装wget工具：yum install wget
命令格式：wget 参数 下载地址
使用wget -h 可以查看命令使用帮助
示例：
 使用wget下载单个文件  wget http://www.minjieren.com/wordpress-3.1-zh_CN.zip 以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。默认的下载地址为当前的目录
使用wget -O下载并以不同的文件名保存  wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080  wget默认会以最后一个符合”/”的后面的字符来命令，对于动态链接的下载通常文件名会不正确。
 错误：下面的例子会下载一个文件并以名称download.aspx?id=1080保存
wget http://www.minjieren.com/download?id=1 即使下载的文件是zip格式，它仍然以download.php?id=1080命令。
正确：为了解决这个问题，我们可以使用参数-O来指定一个文件名：
使用wget -c断点续传  wget -c http://www.minjieren.com/wordpress-3.1-zh_CN.zip 使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数
使用wget -b后台下载  对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载。
wget -b http://www.minjieren.com/wordpress-3.1-zh_CN.zip 你可以使用以下命令来察看下载进度：
tail -f wget-log 伪装代理名称下载  wget --user-agent=&amp;quot;Mozilla/5.0 (Windows; U; Windows NT 6.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%9B%91%E6%8E%A7%E5%85%B6%E4%BB%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%9B%91%E6%8E%A7%E5%85%B6%E4%BB%96/</guid>
      <description>Linux常用命令（监控、其他） 性能监控和优化命令 top
ps
free
vmstat
iostat
lsof 列出谁在使用某个特定的udp端口
lsof -i:8080
其他命令 查看系统的版本
cat /etc/redhat-release 查看内核版本
cat /proc/version diff
grep
wc</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%BD%91%E7%BB%9C%E7%A3%81%E7%9B%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%BD%91%E7%BB%9C%E7%A3%81%E7%9B%98/</guid>
      <description>Linux常用命令（网络、磁盘） 网络命令 ifconfig 许多windows非常熟悉ipconfig命令行工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有一个类似的工具，也就是ifconfig(interfaces config)。通常需要以root身份登录或使用sudo以便在Linux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息，还可以修改这些配置。
1．命令格式：
ifconfig [网络设备] [参数]
2．命令功能：
ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。
3．命令参数：
up 启动指定网络设备/网卡。
down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。
arp 设置指定网卡是否支持ARP协议。
-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包
-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包
-a 显示全部接口信息
-s 显示摘要信息（类似于 netstat -i）
add 给指定网卡配置IPv6地址
del 删除指定网卡的IPv6地址
&amp;lt;硬件地址&amp;gt; 配置网卡最大的传输单元
mtu&amp;lt;字节数&amp;gt; 设置网卡的最大传输单元 (bytes)
netmask&amp;lt;子网掩码&amp;gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。
tunel 建立隧道
dstaddr 设定一个远端地址，建立点对点通信
-broadcast&amp;lt;地址&amp;gt; 为指定网卡设置广播协议
-pointtopoint&amp;lt;地址&amp;gt; 为网卡设置点对点通讯协议
multicast 为网卡设置组播标志
address 为网卡设置IPv4地址
txqueuelen&amp;lt;长度&amp;gt; 为网卡设置传输列队的长度
示例  ifconfig 显示网络设备信息
eth0 表示第一块网卡
lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。
up代表网卡的开启状态，RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节
inet 代表网卡的ip地址
ether 代表网卡的mac地址</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>vim使用操作 操作图 第一级 存活  i insert模式，esc回到normal模式 x 删除当前光标所在的一个字符 ：wq 存盘+退出（：w 存盘，：q退出） dd 删除当前行，并把删除的行存在剪切板 p 粘贴剪切板 hjkl ←↓↑→ （j很像下箭头）  第二级 基础操作 各种插入模式  a 在光标后插入 o 在当前行后插入一个新行 O 在当前行前插入一个新行 cw 替换从光标所在位置后到一个单词结尾的字符  简单的移动光标  0 数字0，到行头 gg 到文档的第一行 G 到文档的最后一行 w 移动到下一个单词的行首 b 移动到上一个单词的行首 e 移动到单词的结尾 ge 移动到上一个单词的结尾 ^ 到本行第一个不是blank字符的位置（blank字符：空格，tab，换行，回车） $ 到本行的行尾 g_ 到本行最并后一个blank字符的位置  打开/保存/退出/改变文件  :e &amp;lt;path/to/file&amp;gt; 打开一个文件 :w 存盘 ：saveas &amp;lt;path/to/file&amp;gt; 另存为 :x,ZZ,：wq 保存并退出（:x 表示仅在需要时保存，ZZ不需要输入冒号回车 :q! 退出不保存 :qa!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84ssh%E7%AB%AF%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E7%9A%84ssh%E7%AB%AF%E5%8F%A3/</guid>
      <description>Linux更改默认的ssh端口 起因 vps在使用xshell连接的时候发现提示： 有多次失败的尝试登陆
问题 在互联网上有人尝试使用默认的22端口来进行破解登陆
解决（centos7 环境下）  使用命令vi /etc/ssh/sshd_config编辑配置文件，添加新的端口，使得可以使用新的端口访问  port 22 port xxxx 重启ssh配置使其生效 在centos7中，使用命令  /etc/init.d/sshd restart 提示无效 于是使用命令
systemctl enable sshd.service systemctl restart sshd.service 使用新的端口xxx进行登陆，成功后vi /etc/ssh/sshd_config编辑配置删除原来的22端口  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/mysql%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/mysql%E6%93%8D%E4%BD%9C/</guid>
      <description>mysql命令查询手册 常用指令  建立数据库 create datebase [name] 设置数据库编码 set names utf8 删除数据库 drop datebase [name] 导出sql文件 mysqldump -h[主机所在IP] -u[用户名] -p [要导出的数据库]&amp;gt;[导出的路径//[文件名].sql] mysqldump -h localhost -u root -p test1&amp;gt;f://coding/test1.sql 导入sql文件 source [sql文件path][sql文件名称] 显示数据库所有表 show tables 显示表的结构 describe 表名; 显示表的数据 select * from table  需要注意的问题  linux下mysql大小写敏感  在mysqld下添加 lower_case_table_names=1 重启 mysql service mysql restart
   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/centos7%E5%8D%87%E7%BA%A7python2%E5%88%B0python3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/centos7%E5%8D%87%E7%BA%A7python2%E5%88%B0python3/</guid>
      <description>Centos7升级python2到python3 服务器自带的python版本为2.7,需要升级到python3,遇到了一些坑,记录一下.
准备工作 安装和编译工作很顺利,但是发现pip版本不能被正确安装,出现下面的错误
Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; File &amp;quot;/usr/local/lib/python3.4/multiprocessing/context.py&amp;quot;, line 132, in Value from .sharedctypes import Value File &amp;quot;/usr/local/lib/python3.4/multiprocessing/sharedctypes.py&amp;quot;, line 10, in &amp;lt; module&amp;gt; import ctypes File &amp;quot;/usr/local/lib/python3.4/ctypes/__init__.py&amp;quot;, line 7, in &amp;lt;module&amp;gt; from _ctypes import Union, Structure, Array ImportError: No module named &#39;_ctypes&#39; 查阅资料发现需要提前安装好一个依赖,pip才可以被正确安装
yum install libffi-devel 安装 # 下载 wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz #解压源码包 tar -zxvf Python-3.7.0.tgz #创建安装目录 mkdir /usr/local/python3 cd Python-3.7.0/ #安装到指定目录 .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/pure-ftpd%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/pure-ftpd%E5%AE%89%E8%A3%85/</guid>
      <description>Pureftpd安装 安装 使用命令 yum -y install epel-release &amp;amp;&amp;amp; yum -y install pure-ftpd
生产配置文件 /usr/sbin/pure-config.pl /etc/pure-ftpd/pure-ftpd.conf
权限与用户 groupadd ftpgroup //新建系统组 useradd -g ftpgroup -d /data/ftp -s /sbin/nologin ftpuser //新建一个FTP用户，不创建用户目录，假定已经存在一个FTP root作为FTP的根目录。 chown ftpuser.ftpgroup /data/ftp/ -R pure-pw useradd haigeek –u ftpuser –d /data/ftp –m //命令格式很好懂，pure-pw 命令使用useradd 需要添加的用户名， -u标明虚拟用户并且与系统用户权限关联，-d指定了系统用户Home目录中的子目录，且被限制在这个子目录里面（此处是否被限制与上文的conf文件设定相关）如果需要访问系统用户的HOME Directory，则直接使用参数 -D，-m则写入用户数据库，用户设置即时生效，无需重启进程。 pure-config.pl etc/pure-ftpd/pure-ftpd.conf &amp;amp;//后台启动进程。 groupadd -g 1000 ftpgroup useradd -g 1000 -u 1000 -d /data/ftp/ -s /sbin/nologin ftpuser
chown ftpuser.ftpgroup /data/ftp/ -R 重启 /etc/init.d/pure-ftpd restart</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/vsftpd%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/vsftpd%E5%AE%89%E8%A3%85/</guid>
      <description>Linux下vsftpd的安装与配置 安装 使用yum进行安装
yum install vsftpd vsftpd的几个概念 用户设置 vsftpd支持以下三种模式的身份认证
1、匿名模式
2、本地用户身份认证模式
3、虚拟用户身份认证模式
在实际的使用中，使用本地身份认证模式是最为简单、相对安全的一种认证模式。
centos7默认已经存在ftp这个用户，假如没有特殊的用户名要求，可以直接使用ftp用户，该用户的主目录为/var/ftp
使用passwd修改ftp的密码即可使用ftp用户进行登录；
假如需要指定新的用户来使用ftp，那就新建本地用户即可。
连接模式 ftp的连接主要有两种模式，分别是主动模式和被动模式。
FTP只通过TCP连接,没有用于FTP的UDP组件.FTP不同于其他服务的是它使用了两个端口, 一个数据端口和一个命令端口(或称为控制端口)。通常21端口是命令端口，20端口是数据端口。当混入主动/被动模式的概念时，数据端口就有可能不是20了。
主动模式 主动模式下，FTP客户端从任意的非特殊的端口（N &amp;gt; 1023）连入到FTP服务器的命令端口&amp;ndash;21端口。然后客户端在N+1（N+1 &amp;gt;= 1024）端口监听，并且通过N+1（N+1 &amp;gt;= 1024）端口发送命令给FTP服务器。服务器会反过来连接用户本地指定的数据端口，比如20端口。
命令连接：客户端 &amp;gt;1023端口 -&amp;gt; 服务器 21端口
数据连接：客户端 &amp;gt;1023端口 &amp;lt;- 服务器 20端口
被动模式 为了解决服务器发起到客户的连接的问题，人们开发了一种不同的FTP连接方式。这就是所谓的被动方式，或者叫做PASV，当客户端通知服务器它处于被动模式时才启用。
在被动方式FTP中，命令连接和数据连接都由客户端，这样就可以解决从服务器到客户端的数据端口的入方向连接被防火墙过滤掉的问题。当开启一个FTP连接时，客户端打开两个任意的非特权本地端口（N &amp;gt;; 1024和N+1）。第一个端口连接服务器的21端口，但与主动方式的FTP不同，客户端不会提交PORT命令并允许服务器来回连它的数据端口，而是提交PASV命令。这样做的结果是服务器会开启一个任意的非特权端口（P &amp;gt;; 1024），并发送PORT P命令给客户端。然后客户端发起从本地端口N+1到服务器的端口P的连接用来传送数据。
命令连接：客户端 &amp;gt;1023端口 -&amp;gt; 服务器 21端口
数据连接：客户端 &amp;gt;1023端口 -&amp;gt; 服务器 &amp;gt;1023端口
使用chrome和第三方的连接工具（filezilla等）时，默认是使用被动模式进行连接的
针对两种不同的ftp配置要进行防火墙的设置 主动模式：打开20、21端口
被动模式：打开21和被动模式使用的数据传输端口范围
配置 vsftpd的停止与启动 systemctl start vsftpd.service #启动 systemctl restart vsftpd.service #重启 systemctl stop vsftpd.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/linux%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/linux%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>Linux运维常用命令 SCP scp从远程拷贝数据到本地
-P 端口 P一定是大写
~ scp -P 22 -r root@192.168.1.1:/root/oracleData/dist/temp/ ~/Downloads ~ scp -P 22 -r /Users/haigeek/Downloads/DGPOMS_20190814NEW.DMP root@192.168.1.1:/root/oracleData/dist/temp/ SSH 增加密钥免密登录服务器
设置权限
sudo chmod 600 key.pem 安装密钥
ssh-add -K xxx.pem 端口 netstat -tupln |grep 1101 lsof -i|grep 13997 进程 ps -ef|grep tomcat # 查看进程的详细信息 ll /proc/PID 查看配置 # 查看cpu信息 cat /proc/cpuinfo # 查看内存信息 free </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/shell%E5%88%86%E4%BA%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/shell%E5%88%86%E4%BA%AB/</guid>
      <description>shell脚本分享 一、介绍shell Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。
Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。
Shell 脚本（shell script），是一种为 shell 编写的脚本程序。
业界所说的 shell 通常都是指 shell 脚本。
shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。
为什么使用shell脚本？
简化对于多个重复命令的操作，适用于批处理。（原本是觉得docker没有怎么简化操作，每次都要敲那么多代码，后来发现可以用shell脚本写脚本批处理运行之）。
shell脚本以.sh为文件名的后缀(不强制，规范而已)
脚本第一行以#!/bin/bash或者 #!/bin/sh 开头（不是必须的）
执行：
1. chmod +x 脚本名 : 授予执行权 然后可以 ./文件名运行 2. sh 脚本名 3. /bin/bash 脚本名 4. bash 脚本名  二、代码实操 hello world vim helloworld.sh #!/bin/bash echo &amp;#34;hello wolrd!!!&amp;#34; 运行
sh helloworld.sh 变量 # 给变量名赋值 注意等于号中间没有括号 变量名=变量值 #使用变量名 $变量名 或者 ${变量名} #只读变量 readonly 变量名=变量值; #变量名=变量值2; 标记了只读变量 修改会报错 #删除变量 unset 变量名 #!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/linux/vsftp%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/linux/vsftp%E4%B9%B1%E7%A0%81/</guid>
      <description>vsftp windows资源管理器上传文件乱码问题 使用文件名编码工具convmv
convmv -f UTF-8 -t GBK -r ./  -f UTF-8 代表原来的编码utf-8, -t GBK 代表转换后的代码 -r 代表处理子文件夹 ./ 代表对当前文件夹进行操作  convmvfs /ftp/pub_gbk -o srcdir=/ftp/pub, icharset=utf8,ocharset=gbk
convmv -f UTF-8 -t GBK -r ./ &amp;ndash;notest</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/xdiamond%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/xdiamond%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</guid>
      <description>xdiamond 统一配置中心 1. 部署并启动 xdiamond (1) 下载 xdiamond 源码 或者 xdiamond 包(下载包可忽略下面操作，直接引用或启动) (2) 修改 xdiamond 的 jdk 版本为 1.8，使用 tomcat8 服务器  此处升级 jdk 版本与 tomcat 版本主要是为了更好集成高配置环境项目用，无特殊要求可不进行升级
  升级 xdiamond-rootpom 的 pom.xml 配置文件中的 maven-compiler-plugin 插件的 jdk 配置为1.8   &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt; &amp;lt;encoding&amp;gt;${project.build.sourceEncoding}&amp;lt;/encoding&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt;  升级 xdiamond-client-example 的 pom.xml 配置文件的 maven.compiler.target 和 maven.compiler.source 参数为 1.8   &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt; (3) 修改项目配置  xdiamond-rootpom 的 pom.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83apollo%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83apollo%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>全局配置中心Apollo的使用 多环境 核心配置热更新 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/%E5%9F%BA%E4%BA%8Eoauth2%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/%E5%9F%BA%E4%BA%8Eoauth2%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</guid>
      <description>基于Oauth2的单点登录 cookie-session机制
client对接口进行访问
重定向到客户端的登录接口
客户端的登录接口重定向到认证中心的/authorize接口 接口参数有：clientId；redirect_uri
客户端获取到code，携带code进行请求
token机制</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/backend/%E7%BC%93%E5%AD%98%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/backend/%E7%BC%93%E5%AD%98%E5%88%9D%E6%8E%A2/</guid>
      <description>缓存初探 Springboot使用Redis缓存 缓存可能会出现的几个场景 缓存雪崩 缓存雪崩是指原缓存失效，新缓存未到达之前，所有请求都去请求数据库，从而给数据库带来巨大的压力。
处理方法：
1、并发不大的时候，可以使用加锁排队
2、给每一个缓存的数据添加相应的缓存标记，记录缓存是否失效，如果缓存失效，则更新缓存。
3、为key设置不同的缓存时间，这样可以减少同时请求的概率。
缓存穿透 缓存穿透是指用户查询数据，在数据库中不存在，自然在缓存中也不存在。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。
处理方法：
1、使用布隆过滤器，将可能存在的数据存到一个足够大的bitmap中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。
2、假如查询的数据返回为空（不管是数据不存在还是系统故障）我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库
缓存预热 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候， 先查询数据库，然后再将数据缓存的问题!用户直接查询事先被预热的缓存数据。
缓存更新 除了缓存服务器自带的缓存策略之外，还可以在具体的代码中设置缓存的更新
1、定时清理过去的缓存
2、当有用户请求过来时，判断缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。
缓存降级 当访问量剧增、服务出现问题(如响应时间慢或不响应)或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的(如加入购物车、结算)。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/database/oracle/oracle%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/database/oracle/oracle%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E8%AE%BE%E7%BD%AE/</guid>
      <description>oracle安全策略设置
1、数据库未设置密码复杂度策略和密码定期更新策略
先查看用户密码过期策略，默认是DEFAULT
select username,profile from dba_users where username in (&#39;TFDS&#39;,&#39;SYSTEM&#39;); 查看DEFAULT策略的过期时间（UNLIMITED表示无限制）
select * from dba_profiles where profile=&#39;DEFAULT&#39; and resource_name=&#39;PASSWORD_LIFE_TIME&#39;; 修改默认过期天数（Oracle默认是180天，如果一个季度一修改是90天）
alter profile default limit password_life_time 180; 2、限制非法登录尝试次数，超尝试次数后实现锁定或自动退出,登录超时
查看登录失败限制次数
select * from dba_profiles s where s.profile=&#39;DEFAULT&#39; and resource_name=&#39;FAILED_LOGIN_ATTEMPTS&#39; 修改登录失败限制次数
alter profile default limit failed_login_attempts 10; 查看登录超时设置
select * from dba_profiles where profile =&#39;DEFAULT&#39; and resource_name=&#39;IDLE_TIME&#39; 修改登录超时
alter profile default limit idle_time 30; 3、开启数据库审计功能
检测是否开启审计
conn /as sysdba show parameter audit 执行结果：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/spring/spring-ioc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/spring/spring-ioc/</guid>
      <description>Spring IOC 什么是Ioc与DI IoC—Inversion of Control，即“控制反转”，是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制； DI-Dependency Injection，即依赖注入，是组件之间的依赖关系由容器在运行期间决定，即由容器动态的将某个依赖关系注入到组件之中，依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。
关于DI的理解：  谁依赖于谁：应用程序依赖于IoC容器 为什么需要依赖：应用程序需要IoC程序来提供对象需要的外部资源 谁注入了谁：IoC容器注入应用程序的某个对象，应用程序依赖的对象 注入了什么：注入了某个对象需要的外部资源。相对IoC而言，依赖注入明确描述了被注入对象依赖IoC容器所配置的依赖对象。  IoC容器的概念 IoC就是具有依赖注入功能的容器，IoC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖，应用程序无需直接在代码中new相关的对象，应用程序由IoC容器进行组装，在Spring中BeanFactory是Ioc容器的实际代表者，Spring IoC容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。
bean的概念 由IoC容器管理的那些组成你应用程序的对象我们就叫它Bean， Bean就是由Spring容器初始化、装配及管理的对象
Spring容器装配Bean xml方式 示例xml
&amp;lt;!--声明accountDao对象，交给spring创建--&amp;gt; &amp;lt;bean name=&amp;#34;accountDao&amp;#34; class=&amp;#34;com.springIoc.dao.impl.AccountDaoImpl&amp;#34;/&amp;gt; &amp;lt;!--声明accountService对象，交给spring创建--&amp;gt; &amp;lt;bean name=&amp;#34;accountService&amp;#34; class=&amp;#34;com.springIoc.service.impl.AccountServiceImpl&amp;#34;&amp;gt; &amp;lt;!--注入accountDao对象，需要set方法--&amp;gt; &amp;lt;property name=&amp;#34;accountDao&amp;#34; ref=&amp;#34;accountDao&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; xml配置文件的方式对bean进行声明和管理，每一个bean标签都代表着需要被创建的对象并通过property标签可以为该类注入其他依赖对象。通过ClassPathXmlApplicationContext去加载spring的配置文件，接着获取想要的实例bean并调用相应方法执行。对于ClassPathXmlApplicationContext默认加载classpath路径下的文件，只需指明对应文件的classpath路径即可。如果存在多个配置文件，则只需分别传递即可，ClassPathXmlApplicationContext是一个可以接收可变参数的构造函数。实际上ClassPathXmlApplicationContext还有一个孪生兄弟FileSystemXmlApplicationContext，它默认为项目工作路径 即项目的根目录。
setter注入方式 Setter注入被注入的属性要有Set方法，通过调用Bean类的setter方法进行注入依赖，Setter注入是在bean实例创建完成后执行的1. 通过set注入对象，对象注入使用ref&amp;lt;!--声明accountDao对象，交给spring创建--&amp;gt; &amp;lt;bean name=&amp;#34;accountDao&amp;#34; class=&amp;#34;com.springIoc.dao.impl.AccountDaoImpl&amp;#34;/&amp;gt; &amp;lt;!--声明accountService对象，交给spring创建--&amp;gt; &amp;lt;bean name=&amp;#34;accountService&amp;#34; class=&amp;#34;com.springIoc.service.impl.AccountServiceImpl&amp;#34;&amp;gt; &amp;lt;!--注入accountDao对象，需要set方法--&amp;gt; &amp;lt;property name=&amp;#34;accountDao&amp;#34; ref=&amp;#34;accountDao&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; 2. 通过Set注入简单值和map、set、list、数组&amp;lt;bean id=&amp;#34;account&amp;#34; scope=&amp;#34;prototype&amp;#34; class=&amp;#34;com.springIoc.pojo.Account&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;name&amp;#34; value=&amp;#34;i am springIoc&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;pwd&amp;#34; value=&amp;#34;123&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;books&amp;#34;&amp;gt; &amp;lt;map&amp;gt; &amp;lt;entry key=&amp;#34;10&amp;#34; value=&amp;#34;java&amp;#34;/&amp;gt; &amp;lt;entry key=&amp;#34;11&amp;#34; value=&amp;#34;java1&amp;#34;/&amp;gt; &amp;lt;entry key=&amp;#34;12&amp;#34; value=&amp;#34;java2&amp;#34;/&amp;gt; &amp;lt;/map&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;friends&amp;#34;&amp;gt; &amp;lt;set&amp;gt; &amp;lt;value&amp;gt;tom&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;jerry&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;jack&amp;lt;/value&amp;gt; &amp;lt;/set&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;citys&amp;#34;&amp;gt; &amp;lt;list&amp;gt; &amp;lt;value&amp;gt;shanghai&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;zhengzhou&amp;lt;/value&amp;gt; &amp;lt;value&amp;gt;kunming&amp;lt;/value&amp;gt; &amp;lt;/list&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; 构造函数注入 构造注入也就是通过构造方法注入依赖，构造函数的参数一般情况下就是依赖项，spring容器会根据bean中指定的构造函数参数来决定调用那个构造函数public class AccountServiceImpl implements AccountService { /** * 需要注入的对象 */ private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/spring/springaop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/spring/springaop/</guid>
      <description>SpringAop AOP的概念 AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting）。
简单理解就是将与核心业务无关，但是在整个系统中是具有公共角色的逻辑代码进行封装，减少系统代码的复杂度。
AOP术语 连接点
类里面所有可能被增强的方法，这些类统称为连接点
切入点
类里面有很多方法可以被增强，实际被增强的方式，被称为切入点
增强
增强的逻辑，被称为增强
切面
把增强运用到具体的方法上，这个过程被称为切面
AOP的实现原理 JDK动态代理 CGLIB代理 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/spring/spring%E7%9A%84%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/spring/spring%E7%9A%84%E4%BA%8B%E5%8A%A1/</guid>
      <description>Spring的事务 数据库事务隔离级别 事务传播机制 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/spring/spring%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/spring/spring%E7%AC%94%E8%AE%B01/</guid>
      <description>spring笔记1 spring概念   spring是开源的轻量级框架
  spring核心主要两部分
 aop：面向切面编程 ioc：控制反转 比如有一个类，在类中有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象；把对象的创建不是通过new方式实现，而是交给spring配置创建类对象    spring是一站式框架
spring在javaee三层结构中，每一层都提供不同的解决方法
 web层：springMVC service层：spring的ioc dao层：spring的jdbcTemplate    spring版本
 spring4.x    spring的ioc操作  把对象的创建交给spring的进行管理 ioc操作的两部分  ioc的配置文件方式 ioc的注解方式    ioc底层原理  ioc底层原理使用技术  xml配置文件 dom4j解决xml 工厂设计模式 反射   ioc的过程  创建xml配置文件，配置要创建对象类  &amp;lt;bean id=&amp;#34;userService&amp;#34; class=&amp;#34;cn.haigeek.UserService:/&amp;gt; 创建工厂类，使用dom4j解析配置文件+反射  public class UserFactory{ //返回UserService对象的方法  public static UserService getService(){ //使用dom4j解析xml文件  //根据id值userService，得到id值对应的class属性值  String classVaule=&amp;#34;class属性值&amp;#34;; //使用反射创建类对象  Class clazz=Class.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/spring/spring%E7%AC%94%E8%AE%B02/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/spring/spring%E7%AC%94%E8%AE%B02/</guid>
      <description>spring的bean管理（注解） 注解  代码里面的特殊标记，使用注解可以完成功能 @注解名称（属相名称=属性值） 注解可以使用在类、方法、属性  注解创建对象  在创建对象的类上使用注解实现  @Componebt(value=&amp;#34;user&amp;#34;) 创建对象有四个注解  @Controller ：web层 @Service ：业务层 @Repository： 持久层   创建对象是单实例还是多实例  @Scope(value=&amp;#34;prototype&amp;#34;) 注解注入属性 @Autowized 创建service类，创建dao类，在service得到dao类
 创建service和dao对象 在service类里面定义dao类型属性  @Autowized name属性值写注解创建dao对象value值
Aop AOP概念  面向切面编程，扩展功能不通过修改源代码实现 AOP采用横向抽取机制，取代了传统纵向继承体系重复性代码  AOP原理 AOP相关术语  连接点：类里面哪些方法可以被增强，这些方法被称为连接点 切入点：在类中可以有很多方法被增强，而实际操作中，只操作了某种方法，实际被增强的方法被称为切入点 通知/增强：增强的逻辑，称为增强，比如扩展日志功能，这个日志功能称为增强 切面：把增强应用到具体的方法上面，过程为切面，把增强应用到切入点的过程  spring的aop操作 使用表达式配置切入点  切入点：实际增强的方法 常用的表达式 execution(&amp;lt;访问修饰符&amp;gt;?&amp;lt;返回类型&amp;gt;&amp;lt;方法名&amp;gt;(&amp;lt;参数&amp;gt;)&amp;lt;异常&amp;gt;)  使用注解方式实现  创建对象 在spring配置文件中，开启aop操作 在增强的aop使用注解  spring整合web项目演示  action调用service，service调用dao。问题：每次访问action的时候，都会加载spring配置文件 解决方案  在服务器启动的时候，创建对象加载spring配置文件 底层使用监听器，Servletcontext对象   spring进行了封装  封装了监听器，只需要配置监听器 引入spring整合web项目jar包 加载指定spring文件位置    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/spring/spring%E7%AC%94%E8%AE%B03/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/spring/spring%E7%AC%94%E8%AE%B03/</guid>
      <description>Spring的jdbcTemplate操作 增加  导入jar包 创建对象，设置数据库信息 创建jdbcTemplate对象，设置数据源 调用jdbcTemplate对象里面的方法  修改 删除 查询  jdbcTemplate实现查询，有接口RowMapper，jdbcTemplate针对这个接口没有提供实现类，得到的类型需要自己进行数据封装 查询的具体实现  查询返回某一个值 查询返回某一个对象 jdbcTemplate.queryForObject(sql, rowMapper, args) 第一个参数是sql语句 第二个参数是接口 第三个参数是可变参数 接口的实现：1.从结果集里面把数据得到2.把得到数据封装到对象里面   查询返回一个list对象    Spring配置连接池和使用jdbcTemplate 配置连接池  导入jar包 在配置文件中进行配置 &amp;lt;bean id=&amp;quot;dataSource&amp;quot; class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot;&amp;gt;&amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;property name=&amp;quot;jdbcUrl&amp;quot;value=&amp;quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;amp;characterEncoding=utf8&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;xxxxx&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;property name=&amp;quot;maxPoolSize&amp;quot; value=&amp;quot;3&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;property name=&amp;quot;maxIdleTime&amp;quot; value=&amp;quot;10&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;/bean&amp;gt;  dao 使用jdbcTemplate  创建service和dao，配置service和dao对象，在service注入dao 创建jdbcTemplate对象，把模板注入到dao里面 在jdbcTemplate对象里面注入dataSource  spring的事务管理 事务概念 所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/springboot/springboot%E9%BB%98%E8%AE%A4%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/springboot/springboot%E9%BB%98%E8%AE%A4%E6%97%A5%E5%BF%97/</guid>
      <description>默认的日志系统 默认的日志系统为logback
输出格式 默认的日志输出格式如下：
2017-12-13 10:02:59.897 INFO 17300 --- [ main] com.haigeek.JkfpApplication : Starting JkfpApplication on haigeek with PID 17300 (started by haigeek in F:\coding\java\intellij idear workplace\jkfp)
输出元素的具体内容如下
  时间日期：精确到毫秒
  日志级别：ERROR,INFO,WARN,DEBUG or TRACE
  进程id
  分隔符：&amp;mdash; 标志实际日志的开始
  线程名： 方括号括起来
  logger名：通常使用源代码的类名
  日志内容
  控制台输出 在springboot默认配置了ERROR、WARN和INFO级别的日志输出到控制台。
可通过两种方式切换到DEBUG级别
  在运行了命令后加入debug命令 如：$ java -jar my.jar -debug
  在application.properties中配置debug=true * 该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/springcloud/spring-cloud%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0eurekaconsul/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/springcloud/spring-cloud%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0eurekaconsul/</guid>
      <description>Spring Cloud构建微服务架构：服务注册与发现（Eureka、Consul） 什么是微服务架构 简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTfulAPI的方式互相调用。
服务治理 由于SpringCloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：NetflixEureka、Consul、Zookeeper。在SpringCloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑
Spring Cloud Eureka Spring CloudEureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是SpringCloud的子项目之一，它为Spring Boot应用提供了自配置的NetflixOSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。
创建服务注册中心  创建一个基础的Spring Boot工程，命名为eureka-server，并在pom.xml中引入需要的依赖内容： 通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能 在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties配置文件中增加如下信息： ​  创建服务提供方  创建一个基本的Spring Boot应用。命名为eureka-client，在pom.xml中，加入如下配置： 实现/dc请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。 最后在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。 我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作 通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/springcloud/spring-cloud-alibaba%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/springcloud/spring-cloud-alibaba%E6%A1%86%E6%9E%B6%E5%8D%87%E7%BA%A7/</guid>
      <description>Spring-Cloud-Alibaba框架升级 框架官方地址：https://github.com/alibaba/spring-cloud-alibaba
在官网上有比较详细的介绍
目前的情况：   修改了pom文件的springboot版本
  小部分代码做了适配（主要是mongo版本需要升级）
  指标系统未分离
  升级步骤 1、确定从哪个模块开始升级，整体的升级策略 先升级springboot版本，然后从一个完整的项目入手开始进行框架升级。
2、制定整体框架图，包括使用的版本号和使用的组件模块 确定版本 springboot、springcloud、 spring-Cloud-alibaba版本关系
http://blog.didispace.com/spring-cloud-alibaba-version/
官网提供的版本说明
![image-20200203233250590](/Users/haigeek/Library/Application Support/typora-user-images/image-20200203233250590.png)
明确组件 官网提供的组件说明
![image-20200203233201491](/Users/haigeek/Library/Application Support/typora-user-images/image-20200203233201491.png)
把组件主要分为以下几类，同时考虑其他版本的spring-cloud使用的组件和springboot-Cloud-alibaba的区别 为何要选用alibaba版本
服务注册与发现 是使用Spring Cloud Feign进行服务间的远程http调用还是继续使用dubbo进行服务间的rpc调用
dubbo集成spring-cloud可以参考官方示例（https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/spring-cloud-alibaba-dubbo-examples/README_CN.md）
根据服务的调用方式，可以进一步确定注册中心的选择：nacos还是eureka
全局配置中心 Alibaba提供的是nacos作为全局配置中心
服务熔断与限流 sentinel的融合（参考蒋延坤的demo是在消费者模块进行配置即可）
服务网关 为所有的微服务设置路由、过滤器、断言等，需要考虑在引入网关的情况下，原有的web模块的改造
其他微服务组件 根据官方提供按需引入即可
3、在确定了整体的架构之后，细化以下几点：  现有框架的改动工作量有哪些，假如继续使用dubbo框架，使用rpc进行服务调用，是否还使用一个消费者多个提供者的架构 是否需要确定自有base模块，是否需要规范base包的工具类 业务模块的分割粒度，例如文件存储与转换、用户认证、sso等 是否需要提取作为单独的服务 每一个业务模块的分包规范 每个微服务是否可以独立启动，且尽量减少依赖，同时可以满足分布式部署需求（考虑业务模块的启动方式） 确定代码规范  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/springcloud/springcloud-alibaba%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81rest%E4%B8%8Erpc%E8%B0%83%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/springcloud/springcloud-alibaba%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81rest%E4%B8%8Erpc%E8%B0%83%E7%94%A8/</guid>
      <description>SpringCloud-ALibaba对Rest与Rpc的支持 SpringCloud-ALibaba服务提供方式与调用 这里主要分为三种场景进行介绍，基于SpringCloud-ALibaba微服务体系
SpringCloud传统Rest调用 SpringCloud-ALibaba原生支持基于openfeign的调用方式，即可以按照Spring Cloud Netflix套件下编写微服务的方式来进行服务的暴露和调用，不同的是可以使用nacos进行服务发现，也可以使用其他服务发现（Eureka、zookeeper等），也就是说SpringCloud-ALibaba具有兼容其他微服务套件的能力，可以很好的进行融合。
首先定义接口，这里按照dubbo风格进行接口定义，也可以只是在一个服务模块里进行接口的定义，也可以不定义接口，直接在具体的服务类上设置路由。
接口定义：
public interface RestService { @GetMapping(&amp;#34;/param&amp;#34;) String hello(@RequestParam String para); } 接口实现：
@RestController public class RestServiceImpl implements RestService { @Override public String hello(String para) { return &amp;#34;hello rest &amp;#34;+para; } } 服务调用：
@RestController public class HelloRestController { @Autowired @Lazy private RestService restService; @GetMapping(&amp;#34;/rest/hello&amp;#34;) public String hello(@RequestParam String para){ System.out.println(restService.hello(para)); return restService.hello(para); } 这种方式也是目前我们微服务改造的实现方式
Dubbo的RPC调用 SpringCloud-ALibaba对Dubbo做了很好的融合，甚至可以理解为SpringCloud-ALibaba专门将dubbo迁移到了SpringCloud-ALibaba体系中，服务的注册与发现和使用原生dubbo框架没有差别。
接口定义：
public interface EchoService { String hello(String para); } 接口实现：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/springmvc/springmvc4.x%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/springmvc/springmvc4.x%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</guid>
      <description>SpringMvc4.x常用注解  controller  Controller控制器是通过服务接口定义的提供访问应用程序的一种行为，他解释用户的输入，将其转换为一个模型然后将视图献给用户，使用@Controller定义控制器，Spring使用扫描机制来找到应用程序中所有基于注解的控制器类，需要在SpringMVC的配置文件声明spring-context如下：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:p=&amp;#34;http://www.springframework.org/schema/p&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;org.springframework.samples.petclinic.web&amp;#34;/&amp;gt; &amp;lt;!-- ... --&amp;gt;&amp;lt;/beans&amp;gt;   @Autowired
将依赖注入到SpringMVC最简单的方法是通过注解@Autowired到字段或者方法
  RequestMapping
  将@RequestMapping注解类似将/favsoft这样的URL映射到整个类或特定的处理方法上，类级别的注解映射到特定的请求路径到表单控制器上，而方法级别的注解只是映射一个特定的http方法请求或者http请求参数；
@Controller @RequestMapping(&amp;quot;/favsoft&amp;quot;) public class AnnotationController { @RequestMapping(method=RequestMethod.GET) public String get(){ return &amp;quot;&amp;quot;; } @RequestMapping(value=&amp;quot;/getName&amp;quot;, method = RequestMethod.GET) public String getName(String userName) { return userName; } @RequestMapping(value=&amp;quot;/{day}&amp;quot;, method=RequestMethod.GET) public String getDay(Date day){ DateFormat df = new SimpleDateFormat(&amp;quot;yyyy-MM-dd&amp;quot;); return df.format(day); } @RequestMapping(value=&amp;quot;/addUser&amp;quot;, method=RequestMethod.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/struts2/struts.xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/struts2/struts.xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid>
      <description>struts2核心配置文件struts.xml详解 struts.xml文件示例 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt; &amp;lt;!DOCTYPE struts PUBLIC &amp;#34;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&amp;#34; &amp;#34;http://struts.apache.org/dtds/struts-2.3.dtd&amp;#34;&amp;gt; &amp;lt;struts&amp;gt; &amp;lt;constant name=&amp;#34;struts.enable.DynamicMethodInvocation&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;constant name=&amp;#34;struts.devMode&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;package name=&amp;#34;default&amp;#34; namespace=&amp;#34;/&amp;#34; extends=&amp;#34;struts-default&amp;#34;&amp;gt; &amp;lt;default-action-ref name=&amp;#34;index&amp;#34; /&amp;gt; &amp;lt;global-results&amp;gt; &amp;lt;result name=&amp;#34;error&amp;#34;&amp;gt;/WEB-INF/jsp/error.jsp&amp;lt;/result&amp;gt; &amp;lt;/global-results&amp;gt; &amp;lt;global-exception-mappings&amp;gt; &amp;lt;exception-mapping exception=&amp;#34;java.lang.Exception&amp;#34; result=&amp;#34;error&amp;#34;/&amp;gt; &amp;lt;/global-exception-mappings&amp;gt; &amp;lt;action name=&amp;#34;index&amp;#34;&amp;gt; &amp;lt;result type=&amp;#34;redirectAction&amp;#34;&amp;gt; &amp;lt;param name=&amp;#34;actionName&amp;#34;&amp;gt;HelloWorld&amp;lt;/param&amp;gt; &amp;lt;param name=&amp;#34;namespace&amp;#34;&amp;gt;/example&amp;lt;/param&amp;gt; &amp;lt;/result&amp;gt; &amp;lt;/action&amp;gt; &amp;lt;/package&amp;gt; &amp;lt;include file=&amp;#34;example.xml&amp;#34;/&amp;gt; &amp;lt;!-- Add packages here --&amp;gt; &amp;lt;/struts&amp;gt; constant 包含一些属性设置，他可以改变struts框架的一些行为。例如示例中的 struts.enable.DynamicMethodInvocation 设为true，表示设置动态方法调用为真，而 struts.devMode 表示是否启用开发者模式。
package 在struts中，package用来管理action、result、interceptor、interceptor-stack等配置信息
 name：必须唯一，这样其他package如果引用本package的话，才能找得到。 extends：当本package继承其他package的时候，会继承父package的所有配置属性（例如action、result等等）；由于package的信息获取是按照struts.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/struts2/struts2%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/struts2/struts2%E7%AC%94%E8%AE%B0/</guid>
      <description>struts笔记一 action的访问  使用method方法 使用通配符实现   在action标签里面name属性，name属性值写符号 * ，表示匹配任何内容   动态访问  结果页面配置 全局结果页面  如果多个action，方法里面返回相同值的时候，可以使用全局结果界面配置  局部结果页面配置  当存在全局结果页面配置时，依旧以局部结果页面配置为准  result便签的type属性  type属性：如何到路径里 type属性值：  默认值：转发操作，值是dispatcher 重定向：redirect chain：转发到action redirectAction：重定向到action    Action获取表单提交数据 获取表单提交数据的三种主要方式 使用ActionContext Map&amp;lt;String,Object&amp;gt;getParameters() 返回一个包含所有HttpServletRequest参数信息
 因为方法不是静态的方法，需要创建ActionContext类的对象 ActionContext对象不是new出来的 static ActionContext getContext() 获取当前线程的ActionContext对象 实例  public String execute() throws Exception { //第一种方式：使用ActionContext类获取 	//获取ActionContext对象 	ActionContext context=ActionContext.getContext(); //调用方法得到表单数据 	Map&amp;lt;String, Object&amp;gt; map = context.getParameters(); Set&amp;lt;String&amp;gt; keys=map.keySet(); //根据key得到vaule，使用数组形式是因为输入项可能有复选框 	for(String key:keys){ Object[] obj=(Object[]) map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/javaweb/struts2/struts%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/javaweb/struts2/struts%E7%AE%80%E4%BB%8B/</guid>
      <description>Struts简介 什么是Struts Struts直译过来就是支柱，枝干的意思，它实现了基于javaweb应用的Model-View——Controller设计模式的应用框架
Struts的体系结构 一个请求在Struts2框架中的处理大概会经过以下结构步骤
 客户端发出一个指向Servlet容器（例如Tomcat）的请求 这个请求会经过结构过滤器Filter(ActionContextCleanUP可选过滤器，其他web过滤器如SiteMesh等)，最后到达FilterDispatcher过滤器 接着FilterDispatcher（过滤调度器）过滤器被调用，FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action 如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给Action对象的代理（ActionProxy） ActionProxy通过配置管理器（Configuration Manager）读取框架的相关的配置文件（Struts.xml以及它包含的*.xml配置文件）找到需要调用的Action类 找到需要调用的Action类之后，ActionProxy会创建一个ActionInvocation（动作调用)的实例 ActionInvocation在调用Action的过程之前，会先依次调用相关配置拦截器（Intercepter）执行结果返回结果字符串 ActionInvocation负责查找结果字符串对应的Result。然后再执行这个Result，再返回对应的结果视图（如JSP）来呈现界面 再次调用所用的配置拦截器（调用顺序与第7步相反），然后响应（HttpServletResponse)被返回给浏览器  Struts2的优点  Struts2是非侵入式设计，即不依赖与Servlet API和StrutsAPI Strtus2提供了强大的拦截器，利用拦截器可进行AOP编程（面向切面的编程），实现权限的拦截等功能 Strtus2提供了类型转换器，可以很方便地进行类型转换，例如将特殊的的请求参数转换成需要的类型 Struts2支持多种表现层技术，如JSP、FreeMarker、Vectocity Struts2的输入验证可以对指定的方法进行验证  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/java.lang.nosuchfielderror/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/java.lang.nosuchfielderror/</guid>
      <description>jar版本不一致导致的java.lang.NoSuchFieldError java.lang.NoSuchFieldError: RESULT_CODE_SUCCESS at com.dist.sso.client.filter.JwtFilter.doFilter(JwtFilter.java:85) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) if (responseData.getCode() == ResponseData.RESULT_CODE_SUCCESS) { HttpUtil.writeToResponse(response, responseData); return; } public static final int RESULT_CODE_SUCCESS = 1000; public static final Integer RESULT_CODE_SUCCESS = 1000; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</guid>
      <description>JAVA的数据类型 基本数据类型： 4种整形：int(32bit)、short(16)、long(64)、byte(8)
2种浮点类型：float(32)、double(64)
字符类型 char(16)
布尔类型 boolean
基本数据类型存储在堆中，直接存储值，不需要进行new
引用数据类型 数组、字符串
创建一个数值时，实际上是创建了一个引用数组，每个引用都会有一个自动的初始值null
JAVA是值传递还是引用传递 值传递：在调用方法时候将实参复制一份传递到方法中，当方法对形参进行修改时，不会影响到实参
引用传递：在调用方法时候将实参的地址复制一份传递到方法中，当方法对形参进行修改时，会影响到实参
结论：
对于基本数据类型，是值传递的
对于引用的数据类型，也是传递的，只是这个值传递传递的是对象的引用
JAVA关键字 final的作用 修饰类 final修饰的类不能被继承，被fina修饰的类的方法自动被变成final；String类就是一个final类（假如有一个String的引用，他的引用一定是一个String对象，而不可能是其他类的对象）
一个类具有私有的构造函数，那么这个类就变成了final类
修饰域 将实例域定义为final的时候，构造对象的时候必须初始化这样的域，且不能被修改
修饰方法 被final修饰的方法不能被覆盖
Static 静态域 将域定义为static，那么在这个类中这个static修饰的域只有一个，他属于类而不属于任何独立的对象
静态常量 假如静态常量的static被省略，那么变量就会变成类的实例域，访问的时候需要类的对象来访问。例如：System.out就是一个静态常量
静态方法 静态方法是不能像对象实施操作的方法。因为静态方法不能操作对象，所以不能访问实例域，但是静态方法可以访问静态域
main方法 main方法也是一个静态方法，main方法不对任何对象进行操作，作用在于执行并创建程序所需要的对象
相关面试题： static关键字是什么意思？java中是否可以覆盖（override）一个private或者static的方法
static关键字表明一个成员变量或者成员方法可以在没有所属的类的实例变量的情况下访问
java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
是否可以在static环境中访问非static变量
static变量在java中是属于类的，他在所有的实例中的值是一样的。当类被java虚拟机载入的时候，会对static变量进行初始化。如果代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。
Hashcode、equals、== hashcode hashcode是由对象导出的一个整形值，假如x和y是两个不通的对象，他们的hashcode不会相同，每个对象都有一个默认的hashcode值，其值为对象的存储地址
什么时候需要重写hashcode ==   对于基本数值类型，他们之间的比较可以使用==
  对于引用的数据类型，使用==比较的是他们在内存中存放的地址（堆内存地址）
例如new同一个对象进行比较，结果都是false，因为每new一次都会开辟新的内存空间
  equals JAVA中所有的类都是继承与object这个超类，在Object类中定义了一个equals的方法，equals的源码调用的还是==，因此默认的比较意义不大
因此，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。
关联 equals相等，hashcode必相等，hashcode相等，equals可能不相等</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/java%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/java%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Java静态方法与非静态方法的区别  在外部调用静态方法时，可以使用&amp;quot;类名.方法名&amp;quot;的方式，也可以使用&amp;quot;对象名.方法名&amp;quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 允许不创建对象而调用静态方法，是Java为了减少程序员调用某些常用方法时的麻烦，而允许程序员按照传统的C语言中使用函数的方式来使用方法。典型的例子是前面某些程序中使用&amp;quot;Math.ramdon()&amp;ldquo;来获取随机数。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。 main()方法是一个典型的静态方法，它同样遵循一般静态方法的规则，所以它可以由系统在创建对象之前就调用。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>JAVA的接口与抽象类 接口 接口用来描述每个类具有什么功能，但是不给出功能的具体实现；
注意：在JAVA8中，接口可以有默认实现，通过default关键字实现默认方法，也可以使用static作为静态方法
接口的几个特性：
 接口不能被实例化，但是可以声明接口的变量 接口里的方法都必须被实现 接口支持继承 一个类可以实现多个接口  抽象类 在自上而下的类的继承关系中，位于上层的类更具有通用性，只将这类作为派生或者其他类的基类
 和接口一样，抽象类不能直接被实例化 包含一个或者多个抽象方法的类必须声明为抽象类 抽象类需要被子类实现，假如子类也不能实现这个方法，那么子类也要声明为抽象类 抽象类也可以有具体的数据和方法 类即使没有抽象方法，也可以申明为抽象类 一个类只能继承一个抽象类  接口与抽象类 当使用抽象类来表示通用属性的时候，类是单继承的，所以可以继承的东西有限，但是一个类是可以实现多个接口的；
接口是对动作的抽象；抽象类是对类别进行抽象；
当关注事物的本质的时候，使用抽象类；
当关注操作的时候，使用接口</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/maven%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/maven%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96/</guid>
      <description>maven资源文件下文件的读取 新建一个maven工程后，main目录下会有java和resources两个文件夹，其中java文件夹下存放源代码，resources文件夹下存放一些配置文件等。
classpath classpath是编译后的 以 classes 文件夹为起点的路径，而在ItelliJ IDEA 中编译后的文件会存入out/production下，在maven中会保存到target/classes文件夹
如何读取文件 //获取文件的url地址 String url = This.class.getClassLoader().getResource(&amp;#34;test.json&amp;#34;).getFile(); getResource()方法会去classpath下找这个文件，获取到url resource, 得到这个资源后，调用url.getFile获取到 文件 的绝对路径</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/%E9%81%8D%E5%8E%86map%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E5%9F%BA%E7%A1%80/%E9%81%8D%E5%8E%86map%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>遍历map的几种方法 for-each循环使用entries进行遍历 Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;(); for (Map.Entry&amp;lt;Integer, Integer&amp;gt; entry : map.entrySet()) { System.out.println(&amp;#34;Key = &amp;#34; + entry.getKey() + &amp;#34;, Value = &amp;#34; + entry.getValue()); } 在for-each循环中遍历keys或values Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;(); //遍历map中的键  for (Integer key : map.keySet()) { System.out.println(&amp;#34;Key = &amp;#34; + key); } //遍历map中的值  for (Integer value : map.values()) { System.out.println(&amp;#34;Value = &amp;#34; + value); } 使用Iterator遍历 Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;(); Iterator&amp;lt;Map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java8-optional%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java8-optional%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>Java8 Optional的使用 在Java8中引入了Optional来避免java的空指针问题
基本方法
of() 为非 null 的值创建一个 Optional 实例
isPresent() 如果值存在，返回 true，否则返回 false
get() 返回该对象，有可能返回 null
OfNullable() 如果指定的值为 null，返回一个空的 Optional
ifPresent() 如果实例非空，调用 Comsumer Lambda 表达式
orElse(obj) 如果实例非空，返回该实例，否则返回 obj</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bstream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bstream/</guid>
      <description>Java8新特性之stream Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。
Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。
简单将stream将要处理的元素当作流，流在管道里进行处理，比如筛选， 排序，聚合等。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/javanio%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/javanio%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</guid>
      <description>Java的传统IO与NIO 几种IO模型 阻塞IO  最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象，用户线程发出IO之后，内核回去查看数据是否就绪，如果没有就绪，用户线程就会处于阻塞状态。当数据就绪之后，内核将数据拷贝到用户进程并返回给用户，用户线程解除阻塞状态。
 典型的阻塞 IO 模型的例子为:data = socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。
多线程下的IO 多个客户端同时向服务端发送请求，服务端开启多个线程来处理客户端的连接，每个线程独立完成客户端的请求。
非阻塞IO  当用户线程发出IO之后，可以马上得到一个结果，如果结果是一个error，说明数据还没有准备好。于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。从而导致cpu的占用比价高。
 多路复用IO  多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。
 在多路复用IO中，轮询socker的状态是内核在进行而不是用户进程，因此cpu占用要低于非阻塞IO
信号IO  在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。
 异步IO  异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后， 它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程 发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</guid>
      <description>Java使用自定义注解 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E5%BC%82%E5%B8%B8/</guid>
      <description>Java常见异常总结 异常的分类 异常的继承结构 Error,Exception继承于Throwable，在java中只有Throwable的异常才可以被抛出或者捕获，它是异常处理机制的基本组成类型。
RuntimeException，IOException继承于Exception,Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）
 Error 一般是指与虚拟机有关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议是让程序停止 Exception Exception异常一个派生于RuntimeException，另一个分支包含其他异常，是可以处理的异常,可以捕获且可能恢复，遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常  Exception 又分为可检查（checked）异常和不检查异常
  unchecked异常 派生于Error类和RuntimeException类的异常成为非受查异常，指的是程序的瑕疵和错误，并在运行时无法恢复
  check异常 代表程序不能直接控制的无效的外界的情况（如用户输入，数据库问题，网络异常，文件丢失等），Java认为Checked异常都是可以被处理的异常，所以Java程序必须显示处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误无法编译。
  常见异常的总结    类型 异常名称 说明     RuntimeException OutOfMemoryError 内存溢出   RuntimeException IndexOutOfBoundsException 数组访问越界   RuntimeException NullPointerException 空指针异常   RuntimeException ClassCastException 类型转换异常   RuntimeException ArithmeticExecption 算术异常类   RuntimeException IllegalArgumentException 传递了不合法的参数   RuntimeException IllegalStateException 违法的状态异常   Exception      异常处理的规范 一、尽量不要捕捉类似Exception 这样的通用异常，而是应该捕获特定异常；要保证程序不会捕获到我们不希望捕获的异常，例如我们希望 RuntimeException 被扩散出来，而不是被捕获。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2%E7%AC%94%E8%AE%B0/</guid>
      <description>java核心技术36讲笔记 谈谈final、finally、 finalize有什么不同？ final是可以用来修饰类、方法、变量分别有不同的定义，final修饰的类代表不可以继承拓展，final的变量是不可被修改的，而final代表的方法是不可以被重写的。
finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作
finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。
强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？ 在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。
1 强引用
特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。
2 软引用
特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。
应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
3 弱引用
弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
应用场景：弱应用同样可用于内存敏感的缓存。
4 虚引用
特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 ReferenceQueue queue = new ReferenceQueue (); PhantomReference pr = new PhantomReference (object, queue); 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid>
      <description>Java的动态代理 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E7%9A%84%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E7%9A%84%E5%8F%8D%E5%B0%84/</guid>
      <description>Java的反射  参考自https://www.sczyh30.com/posts/Java/java-reflection-1/
 什么是反射  Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。
 反射是Java语言的特征之一，他允许运行中的Java程序获取自身的信息，并且可以操作类或者对象的内部属性。通过反射，可以得知在运行的时候才能够得知的名称的.class文件，然后生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。
同样的也可以通过反射来创实例，调用实例方法。
使用反射获取类的信息 获取class对象 使用Class的forName静态方法
public static Class&amp;lt;?&amp;gt; forName(String className) //比如在 JDBC 开发中常用此方法加载数据库驱动:  Class.forName(driver); 获取一个对象的class
Class&amp;lt;?&amp;gt; kclass=int.class; Class&amp;lt;?&amp;gt; classInt=Integer.TYPE; 调用某个对象的getClass()方法
StringBuilder str = new StringBuilder(&amp;#34;123&amp;#34;); Class&amp;lt;?&amp;gt; klass = str.getClass(); 判断是否为某个对象的实例 public native boolean isInstance(Object obj); 创建实例 使用Class对象的newInstance()方法创建Class对象的实例
Class&amp;lt;?&amp;gt; c = String.class; Object str = c.newInstance(); 通过Class对象获取指定的Constructor对象，再调用Constructor的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。
//获取String所对应的Class对象 Class&amp;lt;?&amp;gt; c = String.class; //获取String类带一个String参数的构造器 Constructor constructor = c.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/java%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</guid>
      <description>Java线程 Synchronized 的理解
共享内存有两个重要的问题,一个是竞态条件,一个是内存可见性.
竞态条件出现的原因是因为两个线程可能同时执行某一步,取到了相同的值.例如都取到了100,线程1执行后变成了101,线程2执行之后依旧是101;
内存可见性出现的原因是因为</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/netty%E7%9A%84%E5%85%A5%E9%97%A8%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/netty%E7%9A%84%E5%85%A5%E9%97%A8%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>Netty的入门与使用 什么是Netty Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对TCP、UDP 和文件传输的支持，做为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞的。
Netty为什么是高性能的 Reactor模型 首先了解一下Reactor模型
Reactor模式是基于同步I/O的，在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。
标准/典型的Reactor：  步骤1：等待事件到来（Reactor负责）。 步骤2：将读就绪事件分发给用户定义的处理器（Reactor负责）。 步骤3：读数据（用户处理器负责）。 步骤4：处理数据（用户处理器负责）  例如在Reactor中实现读：  注册读就绪事件和相应的事件处理器。 事件分发器等待事件。 事件到来，激活分发器，分发器调用事件对应的处理器。 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。  IO多路复用 IO异步处理 Netty核心概念 Netty的应用 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/%E4%BB%80%E4%B9%88%E6%98%AFrpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/%E4%BB%80%E4%B9%88%E6%98%AFrpc/</guid>
      <description>什么是RPC 我们在本地写一个service，然后本地调用一下，这属于本地调用。
RPC（Remote Procedure Call Protocol）远程调用： 远程过程调用是一种常用的分布式网络通信协议,它允许运行于 一台计算机的程序调用另一台计算机的子程序，同时将网络的通信细节隐藏起来， 使得用户无须额外地为这个交互作用编程。分布式系统之间的通信大都通过RPC实现
如何调用他人的远程服务 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/%E4%BD%BF%E7%94%A8netty%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AArpc%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/java%E9%AB%98%E7%BA%A7/%E4%BD%BF%E7%94%A8netty%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AArpc%E6%A1%86%E6%9E%B6/</guid>
      <description>使用Netty实现一个RPC框架 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/jvm/jvm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/jvm/jvm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>JVM常用命令 jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。
  查看所有的的java程序
jps
  查看java进程jvn的内存分布情况和占用情况
jstat -gc pid
  S0C: 第一个survivor区的容量（单位是KB）
S1C：第二个survivor区的容量（单位是KB）
S0U：第一个survivor区使用的空间（单位KB）
S1U: 第二个survivor区使用的空间（单位KB）
EC：年轻代中Eden区的容量（KB）
EU：年轻代中Eden区使用的空间（单位KB）
OC：Old代（年老代）的容量（单位KB）
OU：Old代（年老代）使用的空间（单位KB）
PC：Perm（持久代）的容量（KB）
PU：Perm（持久代）使用的空间（KB）
YGC： 从程序启动到采样时年轻代GC的次数（Young GC次数）
YGCT：从程序启动到采样时年轻代GC所用的时间（单位s）
FGC：从程序启动到采样时old代GC（FullGC）的次数，准确的说是产生非YGC产生的STW的次数。
​ 表示非YGC的GC时STW的次数，所以如果发生了CMS GC，这个值+2，如果是Parallel Old GC，则+1，如果是full gc，也是+1 ， 此参数的含义在CMS引入之后定义比较模糊。 FGC&amp;gt;0不一定是产生了FullGC。有可能是CMS GC
FGCT：从程序启动到采样时old代GC（FullGC）所用的时间（s）
GCT：从程序启动到采样时GC所用的时间
jstat -gcutil 
GC情况统计，可以查看GC情况，最常用的一个功能
jstat -gcutil 1000 10
每1000ms打印一次 一共打印10次
S0 年轻代中第一个survivor（幸存区）已使用的占当前容量百分比
S1 年轻代中第二个survivor（幸存区）已使用的占当前容量百分比
E 年轻代中Eden（伊甸园）已使用的占当前容量百分比
O old代已使用的占当前容量百分比</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/jvm/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%90%AFjmx%E7%9B%91%E6%8E%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/jvm/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%90%AFjmx%E7%9B%91%E6%8E%A7/</guid>
      <description>远程开启jmx监控
-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8088 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=47.100.177.143 -Xloggc:/home/tomcat/tomcat-8086/logs/gc/tomcat_gc.log</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/web%E5%AE%B9%E5%99%A8/tomcat7-vs-tomcat8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/web%E5%AE%B9%E5%99%A8/tomcat7-vs-tomcat8/</guid>
      <description>Tomcat7 VS Tomcat8 协议的不同 ​	在servlet3.1中实现了非阻塞式的I/O通信
Tomcat7：org.apache.coyote.http11.Http11Protocol
Tomcat8：org.apache.coyote.http11.Http11NioProtocol
Bio：一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。
Nio：利用Java的异步IO处理，可以通过少量的线程处理大量的请求。
WebSocket tomcat8正式支持WebSocket 1.0这个标准的API。
tomcat7中支持不够好。
URIEncoding Tomcat7：默认编码是ISO-8859-1 （URIEncoding）
Tomcat8：默认编码是UTF-8 （uriCharset）
部署方式 部署方式一致
推荐的Tomcat配置 1、Server 端口修改
&amp;lt;Server port=&amp;#34;8005&amp;#34; shutdown=&amp;#34;SHUTDOWN&amp;#34;&amp;gt;&amp;lt;/Server&amp;gt; &amp;lt;!-- port改成 -1 --&amp;gt; &amp;lt;Server port=&amp;#34;-1&amp;#34; shutdown=&amp;#34;SHUTDOWN&amp;#34;&amp;gt;&amp;lt;/Server&amp;gt; 2、打开连接池配置
&amp;lt;!-- 默认被注释 &amp;lt;Executor name=&amp;#34;tomcatThreadPool&amp;#34; namePrefix=&amp;#34;catalina-exec-&amp;#34; maxThreads=&amp;#34;150&amp;#34; minSpareThreads=&amp;#34;4&amp;#34;/&amp;gt; --&amp;gt; &amp;lt;Executor name=&amp;#34;tomcatThreadPool&amp;#34; namePrefix=&amp;#34;catalina-exec-&amp;#34; maxThreads=&amp;#34;300&amp;#34; minSpareThreads=&amp;#34;20&amp;#34; prestartminSpareThreads=&amp;#34;true&amp;#34; maxQueueSize=&amp;#34;100&amp;#34;/&amp;gt;  name: 线程名称 namePrefix: 线程前缀 maxThreads : 最大并发连接数 minSpareThreads：Tomcat启动初始化的线程数 prestartminSpareThreads：在tomcat初始化的时候就初始化minSpareThreads的值 maxQueueSize: 最大的等待队列数，超过则拒绝请求  3、Connector配置
&amp;lt;Connector port=&amp;#34;8080&amp;#34; protocol=&amp;#34;HTTP/1.1&amp;#34; connectionTimeout=&amp;#34;20000&amp;#34; redirectPort=&amp;#34;8443&amp;#34; /&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/web%E5%AE%B9%E5%99%A8/tomcat%E5%8E%9F%E7%90%86%E5%8F%8A%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/web%E5%AE%B9%E5%99%A8/tomcat%E5%8E%9F%E7%90%86%E5%8F%8A%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</guid>
      <description>tomcat原理及启动原理 tomcat的概念 servlet（server applet 服务端小程序）是一种国际组织的协议，约定，tomcat针对servlet协议的规范做了封装，类似的软件还有jetty
tomcat的总体结构 server-&amp;gt;service-&amp;gt;connector&amp;amp;container(engine-&amp;gt;host-&amp;gt;context(wrapper(servlet)))
tomcat的核心组件是connector和container，connector组件是可以被替换，这样可以提供给服务设计者更多的选择，一个container可以对应多个connector，多个connector和一个container就形成一个service，service负责对外提供服务，server提供service的生存环境，整个tomcat的生命周期由server控制
server server的任务是提供一个接口让其他程序访问到service集合，同时要维护它包含的所有的service的生命周期，包括如何初始化，如何结束服务，如何找到别人要访问的service
service connector主要负责对外交流，container主要处理connector接受的请求，主要是处理内部事务，service也就是在connector和container外面多包一层，将他们组装在一起，向外面提供服务，一个service可以设置多个connector，但是只能有一个container容器
connector connect将在某个指定的端口来监听客户的请求，把从socket传递过来的数据，封装成request，传递给engine来处理，并从engine出获得响应并返回用户
container container是一个接口，定义了下属的各种容器，尤其是wrapper,host,engine,context
engine 负责处理来自相关联的service的所有请求，处理后，将结果返回service，而connector是作为service与engine的中间媒介出现的
一个engine下可以配置一个默认主机，每个虚拟主机都有一个域名，当engine获得一个请求时，它把该请求匹配到虚拟主机（host）上，然后把请求交给该主机来处理
engine有一个默认主机，当请求无法匹配到任何一个虚拟主机的时候，将交给默认host来处理，engine以线程的方式来处理host
host 代表一个虚拟主机，每个虚拟主机和某个网络域名相匹配，每个虚拟主机下都可以部署一个或者多个web应用，每个web应用对应于一个context，有一个context path。
当host获得一个请求的时候，将把该请求匹配到某个context上，处理匹配的方法是最长匹配。path==&amp;quot; &amp;ldquo;的Context将成为该Host的默认Context,所有无法和其它Context的路径名匹配的请求都将最终和该默认Context匹配。
context 一个Context对应于一个Web应用，一个Web应用由一个或者多个Servlet组成Context在创建的时候将根据配置文件载入Servlet类。当Context获得请求时，将在自己的映射表(mapping table)中寻找相匹配的Servlet类，如果找到，则执行该类，获得请求的回应，并返回。
wrapper wrapper代表一个servlet，它负责管理一个servlet，包括servlet的装载，初始化，执行以及资源回收，wrapper是最底层的容器，没有子容器了，warpper的实现类是StandardWarpper，StandardWarpper还实现了拥有了一个servlet初始化信息的servletConfig，由此看出StandardWarpper将直接和servlet的各种信息打交道
lifecycle 很多对象都具有生命周期，从初始化、运行、回收等阶段，tomcat中容器相关的很多组件都实现了lifecycle接口，当tomcat启动时，依赖的下层组件会全部进行初始化，并且可以对每个组件生命周期中的事件添加监视器（LifecycleListener）。例如当服务器启动的时候，tomcat需要去调用servlet的init方法和初始化容器等一系列操作，而停止的时候，也需要调用servlet的destory方法。而这些都是通过org.apache.catalina.Lifecycle接口来实现的。由这个类来制定各个组件生命周期的规范。LifecycleEvent是当有监听事件发生的时候，LifecycleEvent会存储时间类型和数据。
tomcat的启动过程  运行startup.bat或者startup.sh文件启动文件，这两个文件最后都会调用，org.apache.catalina.startup包下面Bootstrap类的main方法。 main方法先实例化一个BootStarp实例，接着调用init方法，init方法是生命周期方法 init方法先初始化类加载器createClassLoader，createClassLoader需要传入一个父加载器，初始化完类加载器后，使用反射机制调用org.apache.catalina.startup.Catalina类下的setParentClassLoader方法 调用完init方法执行load方法，load方法通过反射调用Catalina类的load方法 load方法中比较重要的方法就是createStartDigester()，createStartDigester方法主要的作用就是帮我们实例化了所有的服务组件包括server,service和connect。初始化操作完成后，接下来会执行catalina实例的start方法。 从上面加载的组件中，Tomcat会默认加载org.apache.catalina.core.StandardServer作为Server的实例类。 在Server的start的方法里面会执行service的start方法。在createStartDigester()方法里面，会默认加载org.apache.catalina.core.StandardService类。会接着调用Service的start方法。 service中会调用connector的start方法。至此Tomcat启动完毕  tomcat处理一个http请求的过程 假设来自客户的请求为：http://localhost:8080/test/index.jsp
 请求被发送到本机的端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得 Connector把该请求交给它所在service的Engine来处理，并等待来自Engine的回应 Engine获得请求localhost/test/index.jsp，匹配它所拥有的所有虚拟主机host Engine匹配到名为localhost的Host localhost Host获得请求/test/insex.jsp,匹配它所拥有的Context，Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为””的Context去处理） path=”/test”的Context获得请求/wsota_index.jsp，在它的mapping table中寻找对应的servlet Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet和doPost方法 Context把执行完了之后的HttpServletResponse对象返回给Host Host把HttpServletResponse对象返回给Engine Engine把HttpServletResponse对象返回给Connector Connector把HttpServletResponse对象返回给客户browser  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/java/%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/java/%E9%98%BF%E9%87%8Cjava%E8%A7%84%E7%BA%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>阿里巴巴Java开发手册读书笔记
命名风格 类名
  【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外:DO / BO / DTO / VO / AO
  【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从 驼峰形式。
  【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。
  【强制】抽象类命名使用 Abstract 或 Base 开头;异常类命名使用 Exception 结尾;测试类 命名以它要测试的类的名称开始，以 Test 结尾。
  【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。
  【参考】各层命名规约: A) Service/DAO层方法命名规约
  获取单个对象的方法用get做前缀。
  获取多个对象的方法用list做前缀。
  获取统计值的方法用count做前缀。
  插入的方法用save/insert做前缀。
  删除的方法用remove/delete做前缀。 6) 修改的方法用update做前缀。
  B) 领域模型命名规约
  数据对象:xxxDO，xxx即为数据表名。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/other/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/other/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5/</guid>
      <description>左耳朵耗子练级攻略 专业基础篇 编程语言 系统知识 软件设计篇 进阶篇 linux系统、内存、网络  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/other/%E9%9A%8F%E7%AC%94/summer-of-the-band/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/other/%E9%9A%8F%E7%AC%94/summer-of-the-band/</guid>
      <description>Summer of the band 乐队的夏天结束了,产生了Hot5,我不关心这个结果是否公平公正,也不过多去关心音乐背后的其他东西.
在某南京市民离开我们视野之后,我很兴奋能够发现更多的优秀的乐队,迟斌老师(李先生的前经纪人)的频频出镜让我感觉音乐并不是某个人某个乐队而是这个世界上非常美好的事物.
但是我非常感谢优秀的乐队能带给我一股流来冲破平凡生活的常态，能触摸自己心底深处的快乐和悲伤并尽情释放。
抑制不住的想分享想寻找共鸣.
如果让我在这些乐队票选出我心中的top5,他们是这样的:
  刺猬
  新裤子
  海龟
  痛仰
  九连真人
  但是他们没有先后,他们各自有各自的特色.
刺猬 不会做词曲的诗人不是一个好程序员.
看了乐夏最大的收获就是认识了刺猬并深深的喜欢上了他们.
子健不拘小节,不爱洗澡的外表下竟有这么大的才华,北航学霸,唯品会程序员,让我觉得这个这世界太真实了,这个世界真的这么多热爱音乐的人,他们能勇于去追求他们热爱的音乐并希望分型给志同道合的人.
石璐,被称为中国第女鼓手,单亲妈妈.
一帆,程序员,兼职贝斯,自己透露说还没能辞职…&amp;hellip;
第一次听到他们的《火车》的时候真心被冲击到,那种力量和共鸣无以言表.
后来去找他们的歌去听,很多都非常好听,昨晚他们倒数的第二首《光阴 流年 夏恋》,我觉得有种感觉十分熟悉,知道弹幕上有人打出了《山阴路的夏天》,这时候我才明白,原来不同的旋律是可以传达一样的情感的.
最后一首《生之向往》,不知道唱哭了多少人&amp;hellip;
新裤子 新裤子每期的音乐都能让我单曲循环.
裤子在我读大学的时候就加入我的歌单了,最多的还是《没有理想的人不伤心》,摩登的常年压轴乐队,但是一直没看过他们的现场.
这次能这么立体出现在乐夏,非常好.
马东老师在评价彭磊的时候,有段话记得比较清楚,大概意思是,彭磊用口齿不清的那个感觉,却唱出了最真实的情感.我觉得彭磊是一个非常幽默、真实的一个人,一个中年大叔在台上蹦那么高的时候,我十分惊叹原来生命还可以这么活.
在乐夏他的这些歌曲里,非常喜欢他的《生命因你而火热》
上一期少年时代主题赛,《一场游戏一场梦》和梦姐的那句我爱你结合在一起的时候,音乐在颅内炸裂了.
海龟 海龟是真正的艺术家.
马东老师在后来接受黑刀的采访的时候,说31支乐队里最喜欢的就是海龟,我也注意到每次海龟先生出场的时候马东老师都会站起来.海龟先生的舞台效果非常好,李红旗和蒋晗浑身上下透露出的的气质让你觉得这就是艺术家,看着他们的墨镜和时尚的衣着,可能会觉得这是一支不食人间烟火的乐队,但是当我看了他们的女神合作赛和薛凯琪的合作的时候发现他们似乎并不是像他们打扮的那么酷.
直到他们的《Where Are You Going》那一场,真的给我带来了很大的震撼.
痛仰 痛苦的信仰才能换来今天的一切.
在第一期的时候看到痛仰的《再见杰克》,感觉他们觉得自己的江湖地位很高,总是有种居高临下的感觉.
后来他们就是唱了那个被乐评人称为没有起承转合的《我愿意》,但是就是成为的单曲循环歌曲之一,他们也是因为这个被面孔pk掉.
后来在乐队我做东的节目看到了舞台下的高虎,和我想象的完全不一样,我不知道他私下是不是这样的,至少在和九连吃饭的时候,没有什么架子并能够给他们建议,幽默,真实,佛系.
吉他手宋捷,据说十年前被国外的音乐杂志评为中国摇滚十大帅哥,真的很帅.
昨晚的最后一首《公路之歌》,我对痛仰的好感达到了巅峰.
九连真人 九连的眼睛会冒火.
从第一期看到他们的《莫欺少年穷》,就直接被吸引,惊叹竟然有这么摇滚又纯粹的乐队.
后来看到Figure给他们拍的记录片,更加开始佩服他们.
优秀的主唱阿龙,大学的时候组乐队的兄弟如今在音乐节上十分风光,但是现在自己回到家乡,难免有失落的情感.
小学音乐教师阿麦,他们的眼睛真的有火.他的小号真的太棒了.
万里,连平县音乐教父,背着几十万的债务依旧做音乐,他自己说每月收入只是还债务的利息,但是还是希望和外面的音乐多交流.他自己也有家庭和孩子,但是依然选择做音乐,或许这是音乐的魅力所在吧.
超级乐迷 张亚东 王菲和朴树的制作人,特别会说话,慢条斯理,特别懂音乐,直戳内心.嗯,非常好,特别特别好.
老狼 狼哥,李先生死党之一,你看他头发花白,但是就是能带着你蹦起来嗨起来.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/other/%E9%9A%8F%E7%AC%94/%E6%88%91%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E7%8E%A9%E8%B5%B7%E4%BA%86%E9%9F%B3%E4%B9%90%E7%9B%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/other/%E9%9A%8F%E7%AC%94/%E6%88%91%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E7%8E%A9%E8%B5%B7%E4%BA%86%E9%9F%B3%E4%B9%90%E7%9B%92/</guid>
      <description>我又双叒叕玩起了音乐盒 盒子的前半生 之前的1M带宽的小水管服务器到期了，加上朋友说那个播放器速度太慢，体验不好，其实准确来说他没有体验感而言。于是换了一个5M带宽的服务器，拿来不用着实可惜，但是折腾也的确费神费力，不过很久没有这么折腾过了。
做了啥  换了一个移动端的样式框架，页面手机访问友好了 有了一个域名，不用太担心ip换了找不到家了（毕竟我也不知道他可以活到什么时候） 播放的速度或许能比以前快一些 播放列表支持单个专辑或者全部专辑了  没完成的事情  ios13锁屏之后10s左右就停止播放了(能力有限，无法逾越，先认输了。当然在pc端播放还是正常的，我觉得还是像那么回事的 速度无法和网易云或者QQ音乐对比，毕竟人家的带宽和我们不是一个量级的。 老老实实用本地文件或者上传到网易的个人云盘是最靠谱的  问题来了，我还在折腾什么？
Love everybody with respect 一年过去了，对于他的隐姓埋名，感觉还是挺漫长的。但是看到窗外的天又蓝了，路边的花又开了，空气中的风有暖了，又感觉时间好快，春天又来了。
在意的东西或许总是很难忘记，当不存在的时候也就不会再穿插在我们的生活中，我们也不会经常去提及或者去想起。但是他们的的确确，承载了再也不会有的经历，也是难以忘怀的记忆。
于我而言，个人是这样，我所处于的时代应该也是这样。
借用李先生的这句话：Love everybody with respect</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/alfred%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/alfred%E4%BD%BF%E7%94%A8/</guid>
      <description>Alfred使用笔记 基本使用 设置好快捷键即可使用，默认搜索结果包含了应用、设置、文件夹、文档等，可以在设置中设置更多的搜索结果。
 Search Scope：设置 Alfred 查询时会搜索的文件夹，我们在这里可以自己添加和删除文件夹。 Fallbacks：在没有搜索结果时，会调用搜索引擎进行搜索  文件搜索  Quick Search：快速搜索，勾选该选项后，我们可以使用‘（单引号）或者Space（空格键）快速启用打开文件或者文件夹，功能类似于使用Open + 关键字。 Opening Files：输入open打开文件或者文件夹。个人设置成op 关键词 Revealing Files：输入find查询文件或者文件夹的位置。使用commond+c即可完成路径的复制 Inside Files：输入in查找文本文件内含有查询文字的文件  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/git/git-fork%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/git/git-fork%E9%A1%B9%E7%9B%AE/</guid>
      <description>git fork项目 如何和远程保持更新？
主要的操作命令：
 查看目前仓库可以远程更新的信息 git remote -v 配置一个远程更新链接，要拥有git仓库访问权限的 git remote add upstream git@github.com:xxx/xxx.git 拉取远程仓库的代码 git fetch upstream 合并远程仓库的代码 git merge upstream/master 把远程仓库的代码作为新源提交到自己的服务器仓库中 git push   git branch branch_name remote_name/branch 基于远程仓库创建新分支
git checkout -b branch_name remote_name/branch 基于远程仓库创建新分支并且切换到新分支</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/git/git-detail/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/git/git-detail/</guid>
      <description>目录 git基本操作
git进阶操作 
git协同开发实例 
git操作情境讨论（欢迎提出）
基本操作 git安装 在Windows上使用Git，可以从Git官网直接下载安装程序，默认安装即可。安装完成之后会多处git bash和git GUI两个程序，我们使用git bash 采用命令行的方式进行一系列的操作。
本地git仓库 1、什么是本地仓库 版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”
2、本地仓库的建立  在本地选择一个目录，新建文件夹，并在终端打开这个文件夹。 将这个文件夹初始化为仓库，使用命令 git init 将这个文件夹初始化为git可以管理的仓库，那么现在我们的这个本地文件夹就变化了Git可以管理的仓库，在这个文件夹下会有一个隐藏的 .git 文件夹  3、在本地的仓库添加或者修改文件 在本地的仓库进行代码编写的时候，我们首先要明白git中工作区和暂存区的概念。
 工作区  我们在资源管理器里可以看到的文件就是我们的工作区
 暂存区  当我们的代码完成了一个阶段，我们想当前的这个版本在本地仓库进行保存一个版本，也就是commit操作，但是假如我们每次文件修改后都需要进行一次commit，会比较麻烦，所以Git给我们提供了一种方式，就是将修改的文件进行一次add操作，添加到暂存区中，在进行了一些add之后，统一进行commit操作。当然也可以直接每次add之后就进行commit。
git add filename --将文件添加到暂存区 git add . -- 将本地仓库所有的文件添加到暂存区 git commit -m &amp;#34;提交说明&amp;#34; --使用commit将暂存区的文件进行提交到本地的分支，-m 代表本次的提交说明 4、使用git status查看工作区和暂存区的状态 当我们在工作区进行了文件的修改和文件的增加的时候，git status会告诉我们发生了什么变化，来帮助我们进行判断。
远程仓库 1、github和gitlab的区别 github和github都是基于git的web代码仓库管理软件。区别主要在于github上的仓库基本上都是开源的，当然也可以创建私有的代码仓库，但是费用比较昂贵。而gitlab是可以在企业内部搭建，可以创建私有的代码仓库，除此之外，gitlab还有一些其他的高级特性。相同之处是他们都是基于版本管理系统git，都使用git的命令进行操作。
2、远程仓库和本地仓库的关联 将本地的仓库仓库推送到远程是比较安全的，当本地代码出现问题的时候，我们可以很方便在的远程仓库上进行代码的拉取。具体操作如下：
1.如果我们按照上面的步骤已经在本地上建好了一个仓库，想和远程仓库进行关联，我们首先要在远程的仓库上新建一个项目，然后我们使用下面的代码进行关联（http方式）
git remote add origin http://github.com/username/learngit.git username 是远程仓库的用户名，learngit是远程仓库的名称 或者（ssh密钥方式）:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/git/gitlab%E9%A1%B9%E7%9B%AEfork%E6%AD%A5%E9%AA%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/git/gitlab%E9%A1%B9%E7%9B%AEfork%E6%AD%A5%E9%AA%A4/</guid>
      <description>gitlab项目fork步骤 现有的fork和开发步骤 fork步骤  项目负责人新建好仓库文件夹，前端（front-end）、后台（back-end）、计算（gis） 找到基线仓库地址，点击fork按钮会出现要fork到的目标仓库，可以使用ctrl+f输入项目编码快速找到目标仓库，注意看准项目编码后的文件夹名称，例如SH2019GH081/back-end，才是要fork的位置 fork完成之后对fork完成的项目进行定制修改。  开发步骤 在fork完成之后，删除无用的tag和分支，保留这次版本所使用的分支，在这里分两种情况，使用最新版本或者历史版本
使用最新版本   当使用最新版本时，基线的master分支即我们所需要的版本，对于fork过来的仓库，分支只保留一个master分支，也代表着项目的默认分支为master
  clone项目到本地并checkout出开发分支。clone命令默认会clone默认分支到本地
# clone 指定分支到本地，此时会在本地生成一个名为master的本地分支 git clone http://elb-791125809.cn-northwest-1.elb.amazonaws.com.cn:5335/xdata/SH2018GH036/back-end/dgp-dubbo-server-root.git # 基于master checkout出dev分支 git checkout -b dev   在checkout出的本地分支的readme中记录此次版本发布信息（包括使用的版本以及要进行开发的分支），此步骤的目的是为了记录地方项目开发的开始，与基线版本已经分离。并将此dev分支push到远程供大家开发
git push origin dev   版本发布人员在完成上述操作之后，开发人员使用下述命令进行新建dev分支并进行后续的开发
git checkout -b dev origin/dev   使用历史版本  当使用历史版本时候，目前的机制是存在一个历史版本分支，例如使用20191230的版本，就只保留release-2.8.0-20191230，此处需要做一个调整，在仓库设置中将release-2.8.0-20191230作为默认分支（相当于master分支），取消master分支的默认分支属性并删除（master分支超前，已经不再适用） 后续2、3、4与使用最新版本的操作相同  改进建议 目前的基线的分支比较多，有些有用有些没用， 每个版本也有一个分支，这些只在基线开发的时候是可以满足需求，但是fork到地方的项目的时候这些分支都要删除，虽然工作量不大，但是还是有些繁琐。有以下几点建议：
 基线废弃的分支可以删除,因为git分支的理念就是开发完成合并之后删除，当然也存在一些不是为了功能开发而建立的分支，类似副分支的作用，例如 使用tag进行版本发布,使用分支作为版本管理虽然可以满足需求，但是过多的分支对于fork出去的项目是无用的 fork出去的项目最好也能有自己的master分支并使用起来（结合我们的版本发布来看，不一定叫master），因为项目的模块可能有自己特有的子系统（从0到1），那么只有dev的话，也就不存在一个稳定的版本分支了。  改进后的fork和开发步骤 首先最终改进的最终成果为：
 功能分支都是有用的，没有废弃分支 不会随着时间的推移，产生大量的版本分支  假设我们改进之后基线只有master、dev、hotfix、feature-xxx分支（尽可能少，合并完成之后尽快删除），具有每个版本的tag，那么相比现在的步骤有以下变化
  fork步骤不变</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</guid>
      <description>常见问题的解决 git推送到远程错误的文件怎么处理
先回退到前一个版本：
git reset --hard HEAD^
然后强制推送当前这个版本到云端
git push origin HEAD --force
git取消对某个文件的追踪
$ git rm --cached &amp;lt;filename&amp;gt; 如果是目录的话： $ git rm -r --cached &amp;lt;foldername&amp;gt; git使用情境  在本地将一个文件夹初始化为一个仓库，然后又在远程新建了一个仓库，怎么将本地和远程仓库关联   首先尝试将本地的仓库和远程，使用命令 git remote add origin [url] git 提示我们将本地的分支与远程的分支进行关联，使用git push --set-upstream origin master 将远程仓库的数据使用 git pull ... 进行拉取，这个命令相当于拉取并合并，但是在和本地的分支进行合并的时候，会出现冲突 fatal: refusing to merge unrelated histories 这是因为git 认为合并了两个不同的开始提交的仓库，这两个仓库可能不是同一个。 使用git pull origin master --allow-unrelated-histories来进行合并来告诉git我们将这两个仓库进行合并 建议还是先在远程积进行仓库的建立再clone本地进行开发 更新远程分支列表 git remote update origin &amp;ndash;prune  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/git/git%E6%8B%89%E5%8F%96%E5%88%86%E6%94%AF%E4%B8%8A%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/git/git%E6%8B%89%E5%8F%96%E5%88%86%E6%94%AF%E4%B8%8A%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
      <description>git拉取分支上的指定文件夹 # 克隆项目git clone http://elb-zentao-361931552.cn-northwest-1.elb.amazonaws.com.cn:5335/xdata/SH2018GH115/back-end/dgpoms-server-root.git#切换到远程dev分支git checkout -b dev origin/dev# 开启sparsecheckout模式git config core.sparsecheckout true# 设置允许拉取的文件夹echo dgp-dubbo-server-base &amp;gt;&amp;gt; .git/info/sparse-checkoutecho dgp-dg-server-api &amp;gt;&amp;gt; .git/info/sparse-checkout......#重新拉取git checkout dev参考：https://blog.csdn.net/doujiang_zheng/article/details/78635725一个本地分支同时向多个远程分支提交代码 项目根路径中右击git bash# 添加一个远程仓库git remote add origin https://git.oschina.net/Jicklin/bokeyuan.git其中的origin是仓库的名称 可以换成别的#再添加另外一个git remote set-url --add origin https://github.com/jicklin/bokeyuan.git参考：https://www.jianshu.com/p/dee791260538</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/git/linux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/git/linux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85git/</guid>
      <description>linux下编译安装git 移除旧的git
yum remove git 安装依赖
yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker cd到git的目录进行编译
make prefix=/usr/local/git all 安装git至/usr/local/git路径
make prefix=/usr/local/git install 设置环境变量
vim /etc/profile PATH=$PATH:/usr/local/git/bin export PATH 刷新
source /etc/profile </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>idea快捷键 自动代码 fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码
输入user.getBirthday().var+Tab即可生成Date birthday = user.getBirthday()
ctrl+alt+T 生成代码模版
ALT+/ 代码提示
ctrl+j 自动代码
ctrl+p 方法参数提示
查询快捷键 CTRL+G 定位行
ALT+SHIFT+C 查找修改的文件
F3 向下查找关键字出现位置
SHIFT+F3 向上一个关键字出现位置
选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本
编辑类 Ctrl+Shift+Alt+T 重构一切 ctrl+y 删除光标所在行或者选中行 ctrl+w 递进式选择代码 ctrl+b 进入方法定义的地方 操作类 ctrl+ + 打开大括号 ctrl+ - 收起大括号 ctrl+e 打开最近的文件 ctrl+alt+l 格式化代码 Ctrl + Alt + 左方向键退回到上一个操作的地方 （必备） Ctrl + Alt + 右方向键前进到上一个操作的地方 （必备） Ctrl + Shift + /代码块注释 （必备） Ctrl + Shift + o 清理import （必备） Ctrl+Shift+Enter 自动完成</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/item2%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/item2%E9%85%8D%E7%BD%AE/</guid>
      <description>快捷键 常用快捷键
 分窗口操作：shift + command + d（横切）command + d（竖切） 查找功能：command + f ，tab选中，option+回车粘贴 自动完成：command + ; ，呼出自动完成窗口，根据上下文提供内容选择项 粘贴历史：shift + command + h 回放功能：option + command + b 光标去哪了？command + /  设置别名
# 输入typora即可进行文件的编辑 alias typora=&amp;quot;open -a typora&amp;quot; 配置与美化 主题 选择一个zsh主题[murilasso]
官方主题wiki：https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
设置一个item2主题
git clone https://github.com/dracula/iterm.git 导入主题
安装插件 自动补全 git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 修改配置文件
plugins=(git zsh-autosuggestions) 代码高亮 brew install zsh-syntax-highlighting </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/jmeter/jmeter%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/jmeter/jmeter%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/</guid>
      <description>Jmeter性能测试入门 一个简单的测试请求 以一个简单的接口测试为例，了解下进行一次测试需要的必须条件
jmeter的变量 正则表达式提取
json解析器提取
jemter的常用逻辑 逻辑处理器
后置处理器
定时器
配置元件
监听器
jmeter脚本的录制 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>mac使用指南 基本使用  mac的大小写切换为caplock键 mac的command可以理解为win的ctrl mac才的control在系统中的符号是^，主要作用是在按住control的时候，进行点按，可以做到鼠标右键的效果 mac中finder中是没有剪切的选项了，要进行剪切操作的时候，先command+c，在要剪切到的位置使用option+command+v即可 mac退出软件使用 command+q 强制退出软件 option+command+esc  终端 mac默认的终端为bash，和Linux的终端是一致的，我们可以使用命令 cat /etc/shells 来查看系统支持的终端。可以使用命令 chsh -s /bin/zsh来进行终端的切换，zsh表示我要进行切换的终端
finder  finder快捷键 command+N 复制文件路径 cmd+opt+c  截图 系统自带的截图
 command+shift+3 截整个屏幕 command+shift+4 选择截图 command+shift+4+空格 截窗口带阴影 command+shift+4+空格 确定截图面积移动（鼠标按住） command+shift+4+shift 拉伸x或者y截图（鼠标按住） command+shift+4+option 以中心微为主拉伸（鼠标按住）  mac的重装系统 在mac下和win下的重装系统逻辑基本一致，我选择磁盘操作&amp;ndash;&amp;gt;外置启动盘启动，初次之外还有连接网络下载系统的方式，由于网络的原因，(不推荐)
 备份 制作启动盘，在appstore下载系统镜像，使用U盘进行启动盘的制作。  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/mac%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/mac%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/</guid>
      <description>文件树tree的使用
 -d 只展示目录 -I 设置被忽略的目录  tree -d -I &amp;quot;target&amp;quot; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/mac%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/mac%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/</guid>
      <description>环境搭建与软件安装 安装zsh export PATH=&amp;quot;/Users/haigeek/anaconda/bin:/usr/local/bin:/usr/bin:/usr/sbin:/lsbin:/sbin:$PATH&amp;quot;
环境变量 创建软链接
ln -s 源命令位置 目标位置
例如：
ln -s /Users/haigeek/software/apache-maven-3.6.1/bin/mvn /usr/local/bin/mvn
使用
mysql的安装 使用brew安装mysql
brew install mysql 在安装完成之后，会提示我们几条信息，首先提醒我们将mysql添加到环境变量，这是使用的zsh终端，bash终端类似，使用如下指令：
echo &amp;#39;export PATH=&amp;#34;/usr/local/opt/mysql@5.7/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc 在将mysql添加到环境变量之后，启动mysql
mysql.server start 启动之后进行mysql的配置
mysql_secure_installation 配置完成后进行连接
zookeeper 启动，进入bin文件夹 ./zkServer.sh start ./zkServer.sh start-foreground(在前台显示输出)
停止 ./zkServer.sh stop
jenv的使用 jenv是mac下的一款java版本管理软件
安装 brew install jenv 配置（默认的bash） echo &#39;export PATH=&amp;quot;$HOME/.jenv/bin:$PATH&amp;quot;&#39; &amp;gt;&amp;gt; ~/.bash_profile echo &#39;eval &amp;quot;$(jenv init -)&amp;quot;&#39; &amp;gt;&amp;gt; ~/.bash_profile 使用  查看jdk版本  jenv versions  添加jdk  jenv add /System/Library/Java/JavaVirtualMachines/1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/maven/maven%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/maven/maven%E5%85%A5%E9%97%A8/</guid>
      <description>export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/maven/maven%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/maven/maven%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</guid>
      <description>Maven插件实现远程服务器部署 背景 通过 tomcat7-maven-plugin 插件将项目自动部署到本地服务器或远程服务器。tomcat7和8均可通过该插件远程部署项目。
准备   在tomcat-users.xml 文件配置用户权限
  webapps文件下存放manager文件（tomcat一般自带这个文件）
  如果是远程服务器，还需要设置下manager的content.xml文件，不然会出现IP被限制问题。
  启动 tomcat
  提供者自动销毁实例代码，因为Dubbo项目在重新部署的时候，会出现服务被占用的情况。解决办法在提供者util包下新增DubboServerListener类，并在web.xml配置文件中引用它。
package com.dist.util;/*** @author 常志* @create 2019-03-5**/import com.alibaba.dubbo.registry.dubbo.DubboRegistryFactory;import com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class DubboServerListener implements ServletContextListener{/** 日志记录 */private Logger logger = LoggerFactory.getLogger(DubboServerListener.class);@Overridepublic void contextInitialized(ServletContextEvent sce) {System.out.println(&amp;quot;初始化&amp;quot;);}@Overridepublic void contextDestroyed(ServletContextEvent sce) {logger.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/maven/maven%E6%9B%B4%E6%8D%A2%E7%89%88%E6%9C%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/maven/maven%E6%9B%B4%E6%8D%A2%E7%89%88%E6%9C%AC/</guid>
      <description>maven更换版本 #1 设置新的版本号
mvn versions:set -DnewVersion=1.1.0
#2 当新版本号设置不正确时可以撤销新版本号的设置
mvn versions:revert
#3 确认新版本号无误后提交新版本号的设置
mvn versions:commit</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/maven/maven%E7%9A%84%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/maven/maven%E7%9A%84%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%BB%A7%E6%89%BF/</guid>
      <description>maven的依赖与继承 依赖范围 传递依赖发现可以通过使用如下的依赖范围来得到限制：
   范围（scoup） 描述     编译阶段（compile） compile表示被依赖项目需要参与当前项目的编译，当然后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去。默认取值。   供应阶段（provider） provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。   运行阶段（runtime） runntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。   测试阶段（test） 该范围表明相关依赖只在测试编译阶段和执行阶段。   系统阶段（system） 从参与度来说，也provided相同，不过被依赖项不会从maven仓库抓，而是从本地文件系统拿，一定需要配合systemPath属性使用   导入阶段 该范围只在依赖是一个 pom 里定义的依赖时使用。同时，当前工程的POM 文件的部分定义的依赖关系可以取代某特定的 POM。    继承  compile默认是会被继承的 scope为test或provide的依赖不会传递，所以要多个工程指定相同的test依赖还是使用parent pom scope为runtime的依赖被compile传递后还是runtime  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/maven/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%AC%AC%E4%B8%89%E6%96%B9jar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/maven/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E7%AC%AC%E4%B8%89%E6%96%B9jar/</guid>
      <description>安装
mvn install:install-file -DgroupId=&amp;lt;group-id&amp;gt; -DartifactId=&amp;lt;artifact-id&amp;gt; -Dversion=&amp;lt;version&amp;gt; -Dpackaging=&amp;lt;packaging&amp;gt; -Dfile=&amp;lt;path-to-thirdpart-jar-file&amp;gt; 部署
mvn deploy:deploy-file -DgroupId=com.alibaba.platform.shared -DartifactId=xxpt.gateway.shared.client -Dversion=1.1.14 -Dpackaging=jar -Dfile=zwdd-sdk-java-1.1.9.jar -Durl=http://elb-791125809.cn-northwest-1.elb.amazonaws.com.cn:5336/artifactory/libs-release -DrepositoryId=dist-jfrog-repository-release </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/pmd/pmd%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E5%B7%A5%E5%85%B7%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/pmd/pmd%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E5%B7%A5%E5%85%B7%E5%85%A5%E9%97%A8/</guid>
      <description>PMD代码审查工具入门 安装 在官方仓库下载安装包解压后即可直接使用，支持下载的有可运行程序和源码。
下载地址：https://github.com/pmd/pmd/releases/tag/pmd_releases%2F6.17.0
在下载完bin程序可以直接在命令行执行代码检测。
如果需要对检测规则进行自定义，则需要下载src对其中的规则文件进行自定义。
使用与配置 命令行检测 可以通过一个脚本了解命令编写规则
# 准备环境信息 CUR=`PWD` echo 当前工作目录:${CUR} basepath=$(cd `dirname $0`; pwd) echo 当前执行的脚本文件的父目录:${basepath} PMD_HOME=$basepath/pmd-bin-6.17.0 echo PMD_HOME:${PMD_HOME} PROJ_DIR=$(cd ${basepath}; cd ../../; pwd) echo PROJ_DIR:${PROJ_DIR} SRC=${PROJ_DIR}/app/src/main/java FORMAT=html RULE=rulesets/java/basic.xml OUTDIR=${PROJ_DIR} ${PMD_HOME}/bin/run.sh pmd -d ${SRC} -f ${FORMAT} -R ${RULE} &amp;gt;${OUTDIR} 通过bin文件夹下的启动程序启动扫描，
-d 参数指定要扫描的文件或者文件夹
-f 设置设置输出的结果格式
-R 设置使用的扫描规则 （支持自定义路径）默认规则存储在程序的lib包，路径为rulesets/java/basic.xml 支持更改为不同的规则，如rulesets/java/quickstart.xml
&amp;gt; 输出位置
输出的html文件结果如下：
eg：一个使用自定义规则的例子
/Users/haigeek/software/pmd-bin-6.17.0/bin/run.sh pmd -d /Users/haigeek/dev/dist/project/dgp-dis-server-root -f html -R /Users/haigeek/software/pmd-src-6.17.0/pmd-java/src/main/resources/rulesets/java/quickstart-dist.xml &amp;gt;/Users/haigeek/Downloads/result.html 自定义检测规则 pmd默认提供了很多的检测规则供使用，支持对多种语言进行检测。
针对JAVA来说，主要分为以下几个大类：
 Best Practices 最佳实践 Code Style  代码风格 Design 设计 Documentation  文档 Error Prone 容易出错 Multithreading 多线程 Performance 性能 Security 安全 Additional rulesets 附加规则  打开pmd-src-6.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/pmd/pmd%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%AE%A1%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/pmd/pmd%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%AE%A1%E6%9F%A5/</guid>
      <description>PMD代码质量审查 pmd代码规则 关于pmd的规则有官方的介绍文档有详细的介绍：
https://pmd.github.io/latest/pmd_rules_java.html
idea插件 为了在开发中快速完成对代码质量的检测，选择安装pmd插件来完成代码检测的工作
选择文件或者目录进行扫描
选择所有规则进行扫描，扫描结果如下：
扫描结果可以定位到具体的文件位置并给出了具体的修改建议。使用全部的规则会有大量的需要修改的地方，我们在quick-start默认规则做一些自定义修改之后，使用这个规则进行扫描
导入自有的规则：
代码规范调整（自定义） 根据扫描的结果，取消了一些不是非常重要的规范
Error级别 codestyle  ClassNamingConventions  原规则：
&amp;lt;property name=&amp;quot;utilityClassPattern&amp;quot; value=&amp;quot;[A-Z][a-zA-Z0-9]+(Utils?|Helper)&amp;quot; /&amp;gt; 变更：
&amp;lt;property name=&amp;quot;utilityClassPattern&amp;quot; value=&amp;quot;[A-Z][a-zA-Z0-9]*&amp;quot; /&amp;gt; waring级别 codestyle  unnecessaryannotationvalueelement（注解可以不使用value来定义值） 取消  bestpractices  usecollectionisempty 使用java.util.Collection上的isEmpty（）方法来确定集合中是否包含任何元素。将size（）的值与0进行比较不能像inEmpty（）方法那样传达意图。 取消 guardlogstatement 在使用log.info的时候，先检查下log.isInfoEnabled()是否打开，依次来节省不必要的String创建和操作 （取消）  外网代码规范点 对在线填报代码使用quick-start扫描之后，修改了下述规则所设计的代码：
Error级别 codestyle   ClassNamingConventions
class的命名
  methodnamingconventions
方法的驼峰命名
  formalparameternamingconventions
参数的驼峰命名
  localvariablenamingconventions
本地变量驼峰命名
  errorprone   returnemptyarrayratherthannull
返回空数组而不是null
  design   classwithonlyprivateconstructorsshouldbefinal</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/pmd/%E4%BD%BF%E7%94%A8maven%E6%8F%92%E4%BB%B6%E8%BF%9B%E8%A1%8Cpmd%E5%AE%A1%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/pmd/%E4%BD%BF%E7%94%A8maven%E6%8F%92%E4%BB%B6%E8%BF%9B%E8%A1%8Cpmd%E5%AE%A1%E6%9F%A5/</guid>
      <description>在pom文件引入
&amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-pmd-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.13.0&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;sourceEncoding&amp;gt;${project.build.sourceEncoding}&amp;lt;/sourceEncoding&amp;gt; &amp;lt;targetJdk&amp;gt;${maven.compiler.target}&amp;lt;/targetJdk&amp;gt; &amp;lt;printFailingErrors&amp;gt;true&amp;lt;/printFailingErrors&amp;gt; &amp;lt;linkXRef&amp;gt;true&amp;lt;/linkXRef&amp;gt; &amp;lt;!--&amp;lt;rulesets&amp;gt;--&amp;gt; &amp;lt;!--&amp;lt;ruleset&amp;gt;--&amp;gt; &amp;lt;!--${project.basedir}/code-check/quickstart-dist.xml--&amp;gt; &amp;lt;!--&amp;lt;/ruleset&amp;gt;--&amp;gt; &amp;lt;!--&amp;lt;/rulesets&amp;gt;--&amp;gt; &amp;lt;!-- failOnViolation is actually true by default, but can be disabled --&amp;gt; &amp;lt;failOnViolation&amp;gt;true&amp;lt;/failOnViolation&amp;gt; &amp;lt;!-- printFailingErrors is pretty useful --&amp;gt; &amp;lt;printFailingErrors&amp;gt;true&amp;lt;/printFailingErrors&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt; check &amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 打包命令
mvn clean package pmd:pmd -Pdev-docker -pl com.dist.xdata.dus:dus-union -am 在jenkins使用插件进行数据统计
stage(&#39;code-check&#39;) { steps{ //sh &#39;/opt/pmd/pmd-bin-6.16.0/bin/run.sh pmd -d /data/jenkins/worspace/BackEnd_base/${JOB_NAME}/ -f xml -R /opt/pmd/pmd-bin-6.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/windows%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/windows%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/tools/windows%E8%BD%AF%E4%BB%B6%E9%9B%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/windows%E8%BD%AF%E4%BB%B6%E9%9B%86/</guid>
      <description>windows软件集 系统必备软件 通讯  tim(办公版qq) wechat电脑版  影音&amp;amp;播放器  网易云音乐 PotPlayer  开发 环境 数据库
 Oracle mysql 语言 jdk python  开发工具  vscode sublime git idea pytharm vs2008 Developer Express .NET v8.2 pl/sql Navicat for MySQL Navicat Premium SQLyog  系统工具  office listary  系统增强  ccleaner  远程控制  teamview  数据备份与恢复  dropbox 坚果云 Recuva  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/css%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/css%E5%9F%BA%E7%A1%80/</guid>
      <description>层叠样式表（css） 理解层叠样式表 css代码可以放在网页的&amp;lt;head&amp;gt;标签中，也可以将css代码作为单独的文件；css中对元素的样式设置等同于对元素的style设置，当多种样式存在时，html元素内的style属性将覆盖头文件的style元素，而头文件的style元素将覆盖外部样式表。例如
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; herf=&amp;quot;style.css&amp;quot; type=&amp;quot;text/css&amp;quot;/&amp;gt; 创建样式表规则  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/html%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/html%E5%9F%BA%E7%A1%80/</guid>
      <description>html基本语法与常用标签 html文档结构 文件内容以文档类型定义&amp;lt;!DOCTYPE&amp;gt;开始，随后的元素是,该元素是文档的内容，由两部分组成，文件头部和文件体部,这两个部分需要顺序输出
&amp;lt;title&amp;gt;:用于指示文档的标题
&amp;lt;link&amp;gt;:用于链接到外部css文件或者JavaScrip文件
&amp;lt;style&amp;gt;：用于指定文档的样式，该标签的内容是css文本
&amp;lt;script&amp;gt;用于嵌套JavaScript代码
&amp;lt;meta&amp;gt;该元素可以包含和文档相关的信息，比如关键字和文档描述
&amp;lt;base&amp;gt;指出该页面的基url，用于解析相对url
&amp;lt;!-- --&amp;gt;为注释部分
标记是html文档的重要组成部分，例如&amp;lt;html&amp;gt;...&amp;lt;/html&amp;gt;,`&amp;hellip;等均为html标签,html标签可以带属性，属性提供了有关html元素的更多的信息。分为单标记和双标记
 双标记格式如下：  &amp;lt;标记&amp;gt;...&amp;lt;/标记&amp;gt; &amp;lt;标签 属性1=value1， 属性2=value2 ...( )&amp;gt;...&amp;lt;/标签&amp;gt;  单标记格式如下：  &amp;lt;标记&amp;gt; &amp;lt;标记&amp;gt; 属性1=value1， 属性2=value2...&amp;gt; 多个属性之间以空格分离
格式化文本标签   标题标签&amp;lt;hn&amp;gt;
n值表示标题级别，一共有6个等级的标题
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/https%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/https%E5%8E%9F%E7%90%86/</guid>
      <description>https原理初探 证书传递，验证，数据加密，解密
https简介 HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，可以使用下图描述 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/javascript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/javascript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>js基础知识 javasprict输出 操作html元素 使用 document.getElementById(id) 方法，使用 &amp;ldquo;id&amp;rdquo; 属性来标识 HTML 元素
写到文档输出 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;My First Web Page&amp;lt;/h1&amp;gt; &amp;lt;script&amp;gt; document.write(&amp;quot;&amp;lt;p&amp;gt;My First JavaScript&amp;lt;/p&amp;gt;&amp;quot;); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  警告 使用 document.write() 仅仅向文档输出写内容,如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;My First Web Page&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;My First Paragraph.&amp;lt;/p&amp;gt; &amp;lt;button onclick=&amp;quot;myFunction()&amp;quot;&amp;gt;点击这里&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; function myFunction() { document.write(&amp;quot;糟糕！文档消失了。&amp;quot;); } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  js语句 JavaScript 语句向浏览器发出的命令。语句的作用是告诉浏览器该做什么。JavaScript 是脚本语言。浏览器会在读取代码时，逐行地执行脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。
分号 分号用于分隔 JavaScript 语句，通常我们在每条可执行的语句结尾添加分号。
js代码 浏览器会按照编写顺序来执行每条语句。
  js代码块</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/nginx/mac%E5%AE%89%E8%A3%85nginx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/nginx/mac%E5%AE%89%E8%A3%85nginx/</guid>
      <description>mac安装nginx brew install nginx
www目录
/usr/local/var/www
配置文件目录
/usr/local/etc/nginx/nginx.conf</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/nginx/nginx%E5%88%9D%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/nginx/nginx%E5%88%9D%E8%AF%86/</guid>
      <description>Nginx初识 Nginx是什么 Nginx 是一个免费的，开源的，高性能的HTTP服务器和反向代理，以及IMAP / POP3代理服务器。 Nginx 以其高性能，稳定性，丰富的功能，简单的配置和低资源消耗而闻名。Nginx的整体架构如下：
nginx在启动后，会以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程。工作进程以非特权用户运行。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。worker进程则是处理基本的网络事件。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。
nginx包含3类模块：核心模块，基础模块，第三方模块 ht_core核心模块 ht_upstream 基础模块 ht_proxy 基础模块 ht_fastcgi 基础模块还可以添加一些第三方模块，例如memcache客户端和后端的memcached通信。  nginx使用事件驱动模式来处理请求，异步I/O，非阻塞，事件模式是epoll/select等，非常高效，内存使用mmap、aio，高级io sendfile。Nginx的高并发，官方测试支持5万并发连接。实际生产环境能到2-3万并发连接数。10000个非活跃的HTTP keep-alive 连接仅占用约2.5MB内存。三万并发连接下，10个Nginx进程，消耗内存150M。淘宝tengine团队说测试结果是“24G内存机器上，处理并发请求可达200万”。
安装 windows安装 下载地址：http://nginx.org/en/download.html 选择windows版本下载后解压
Linux安装与相关操作  相关库的安装  yum update -y yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel  PCRE pcre-devel PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。 zlib zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。 OpenSSL OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。 nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。  下载源码  wget http://nginx.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</guid>
      <description>Nginx反向代理解决网络问题 场景 在一个网络中，应用服务器所在的网络与用户所在的网络是隔绝的，唯一的联系是用户组可以访问服务器组的某一台服务器的80端口，需要我们只使用这个80端口来完成整个系统的访问。
分析 我们可以使用nginx的反向代理代理我们服务器的地址，通过设置location，进行url的匹配，这样就可以达到访问我们系统的目的。但是整个系统是复杂的，当我们的系统返回来一个ip地址（不同于可访问那台主机的ip和端口）的时候，浏览器是直接请求这个ip地址的，这时候是无法直接访问的，访问被拒绝。 整个请求的流程如下
那么问题就在于在最后一步nginx接收的响应中的信息包含没有被反向代理的ip地址。
处理方法 nginx的代理只能代理本台服务器的不同端口，以及不同的域名。但是并不能代理不同的服务器，当然这个逻辑本来就很荒谬。 那么怎么才可以解决这个问题呢，我们无法从nginx端下手，那就要考虑从应用端进行处理。 我们的应用端会返回不能访问的ip和地址，那么我么可以让服务器给我们返回可以访问的那个地址的ip和端口，也就是返回代理主机的ip，那么装有nginx的主机就可以接受请求，这时候，我们只需要在nginx的配置文件里面将这些请求代理到其正常应该访问的主机和端口即可以实现这个功能。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/nginx/nginx%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/nginx/nginx%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</guid>
      <description>Nginx处理跨域问题 Nginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务。
跨域举例 假设有两个网站，A网站部署在：http://localhost:8181 即本地ip端口81上；B网站部署在：http://localhost:8080 即本地ip端口82上。现在A网站的页面想去访问B网站的信息，这时候浏览器是会报错的，因为形成了跨域。 现在我们的运维前端部署在nginx上，当我们访问http://localhost:8181/dgpoms的时候，我们可以访问到运维系统的首页，但是当登录的时候，前端需要访问的http://localhost:8080/weboms/rest/login这个接口，由于浏览器的同源策略，便出现了跨域的情况。
解决方式 方案一、在服务端设置允许跨域 可以在服务端设置允许跨域访问，设置如下：
@Configuration @ConditionalOnExpression(&amp;#34;${dist.cors.allow}&amp;#34;) public class CorsConfig { @Value(&amp;#34;${dist.cors.mapping}&amp;#34;) private String mapping; @Value(&amp;#34;${dist.cors.origin}&amp;#34;) private String origin; @Value(&amp;#34;${dist.cors.method}&amp;#34;) private String method; @Bean public CorsFilter corsFilter() { //1.添加CORS配置信息  CorsConfiguration config = new CorsConfiguration(); //放行哪些原始域  config.addAllowedOrigin(this.origin); //是否发送Cookie信息  config.setAllowCredentials(true); //放行哪些原始域(请求方式)  config.addAllowedMethod(this.method); //放行哪些原始域(头部信息)  config.addAllowedHeader(this.origin); //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）  //config.addExposedHeader(HttpHeaders.SERVER);  //2.添加映射路径  UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(this.mapping, config); //3.返回新的CorsFilter.  return new CorsFilter(configSource); } } 方案二、使用nginx反向代理处理跨域 使用这种方式，针对现有的运维前端，将接口地址由 http://localhost:8080/weboms修改为/weboms，修改的目的是为了让nginx去帮我们请求接口地址而不是在浏览器直接请求接口地址。 nginx的配置文件如下：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/nginx/nginx%E5%AE%9E%E7%8E%B0tomcat%E9%9B%86%E7%BE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/nginx/nginx%E5%AE%9E%E7%8E%B0tomcat%E9%9B%86%E7%BE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
      <description>Nginx实现Tomcat集群负载均衡 1、负载均衡配置 在nginx的配置文件加入负载均衡组:upstream，定义一个上游服务器集群，关于负载均衡的权重，有一系统的相关设置。
upstream backend { # ip_hash; server s1.barretlee.com; server s2.barretlee.com; } server { location / { proxy_pass http://backend; } } 2、负载均衡的模式 内置负载均衡策略
- 轮询（默认） 相同的权重，当其中一个挂掉的时候，默认会请求其他的机器
- weight  默认为1，将请求平均分配给每台serverupstream tomcats { server 192.168.0.100:8080 weight=2; # 2/6次 server 192.168.0.101:8080 weight=3; # 3/6次 server 192.168.0.102:8080 weight=1; # 1/6次 down; (down 表示单前的server暂时不参与负载)，backup; (其它所有的非backup机器down或者忙的时候，请求backup机器) upstream tomcats { server 192.168.0.100:8080 weight=2 max_fails=3 fail_timeout=15; server 192.168.0.101:8080 down; server 192.168.0.102:8080 backup; } max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回。fail_timeout:max_fails次失败后，暂停的时间 upstream tomcats { server 192.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/nginx/%E4%BD%BF%E7%94%A8nginx%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/nginx/%E4%BD%BF%E7%94%A8nginx%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>使用Nginx作为静态服务器 文件服务器 在nginx的配置文件设置以下几个地方便可实现一个简单的文件服务器
autoindex on; ##显示索引 autoindex_exact_size on; ##显示大小 autoindex_localtime on; ##显示时间  server { listen 8181; server_name localhost; charset utf-8; location / { #静态资源文件服务器,设置根目录  root /Users/haigeek/Downloads; } 设置访问密码：
安装：
yum -y install httpd-tools 生成密码
htpasswd -c /usr/local/nginx/passwd distpass 配置
auth_basic &amp;quot;Please input password&amp;quot;; #这里是验证时的提示信息 auth_basic_user_file /usr/local/src/nginx/passwd; 前后端分离的静态应用 将前端应用部署在nginx的文件夹下，配置好api的地址，可以将nginx作为前端的服务器运行前端应用
server { listen 8181; server_name localhost; charset utf-8; location / { #设置根目录  root /usr/local/var/www; #设置应用首页  index index.html index.htm; } 在浏览器输入对于的ip加端口加应用名即可访问</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/webservice/wdsl%E7%BB%84%E6%88%90%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/webservice/wdsl%E7%BB%84%E6%88%90%E8%A7%A3%E6%9E%90/</guid>
      <description>webservice之WSDL组成解析 types types指定了这个webservice使用了哪些类型
message message指明一个操作所用到的数据类型 例如：
&amp;lt;wsdl:message name=&amp;#34;downloadMaterialResponse&amp;#34;&amp;gt; &amp;lt;wsdl:part name=&amp;#34;return&amp;#34; type=&amp;#34;xsd:string&amp;#34;&amp;gt; &amp;lt;/wsdl:part&amp;gt; &amp;lt;/wsdl:message&amp;gt; &amp;lt;wsdl:message name=&amp;#34;downloadArchiveResponse&amp;#34;&amp;gt; &amp;lt;wsdl:part name=&amp;#34;return&amp;#34; type=&amp;#34;xsd:string&amp;#34;&amp;gt; &amp;lt;/wsdl:part&amp;gt; &amp;lt;/wsdl:message&amp;gt; downloadMaterialResponse和downloadArchiveResponse就是两个操作的数据类型，他们对于的子元素： &amp;lt;wsdl:part name=&amp;ldquo;return&amp;rdquo; type=&amp;ldquo;xsd:string&amp;rdquo;&amp;gt; &amp;lt;/wsdl:part&amp;gt; 指明了具体的类型
portType 指出这个webservice支持哪些操作，哪些操作可以调用，例如：
&amp;lt;wsdl:portType name=&amp;#34;PlanningMaterialWebService&amp;#34;&amp;gt; &amp;lt;wsdl:operation name=&amp;#34;getAttachmentsByKeyword&amp;#34;&amp;gt; &amp;lt;wsdl:input message=&amp;#34;tns:getAttachmentsByKeyword&amp;#34; name=&amp;#34;getAttachmentsByKeyword&amp;#34;&amp;gt; &amp;lt;/wsdl:input&amp;gt; &amp;lt;wsdl:output message=&amp;#34;tns:getAttachmentsByKeywordResponse&amp;#34; name=&amp;#34;getAttachmentsByKeywordResponse&amp;#34;&amp;gt; &amp;lt;/wsdl:output&amp;gt; &amp;lt;/wsdl:operation&amp;gt; &amp;lt;/wsdl:portType&amp;gt; 里面配置了相关的输入和输出
binding soap:binding元素的transport指明传输协议，这里是rpc协议。 operation 指明要暴露给外界调用的操作。 use属性指定输入输出的编码方式。
&amp;lt;wsdl:binding name=&amp;#34;PlanningMaterialWebServiceServiceSoapBinding&amp;#34; type=&amp;#34;tns:PlanningMaterialWebService&amp;#34;&amp;gt; &amp;lt;soap:binding style=&amp;#34;rpc&amp;#34; transport=&amp;#34;http://schemas.xmlsoap.org/soap/http&amp;#34;/&amp;gt; &amp;lt;wsdl:operation name=&amp;#34;getAttachmentsByKeyword&amp;#34;&amp;gt; &amp;lt;soap:operation soapAction=&amp;#34;&amp;#34; style=&amp;#34;rpc&amp;#34;/&amp;gt; &amp;lt;wsdl:input name=&amp;#34;getAttachmentsByKeyword&amp;#34;&amp;gt; &amp;lt;soap:body namespace=&amp;#34;http://www.dist.com.cn/dap&amp;#34; use=&amp;#34;literal&amp;#34;/&amp;gt; &amp;lt;/wsdl:input&amp;gt; &amp;lt;wsdl:output name=&amp;#34;getAttachmentsByKeywordResponse&amp;#34;&amp;gt; &amp;lt;soap:body namespace=&amp;#34;http://www.dist.com.cn/dap&amp;#34; use=&amp;#34;literal&amp;#34;/&amp;gt; &amp;lt;/wsdl:output&amp;gt; &amp;lt;/wsdl:operation&amp;gt; &amp;lt;/wsdl:binding&amp;gt; service 主要是指定服务的一些信息，主要是指定服务的路径，例如：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/web/websocket%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/web/websocket%E5%AD%A6%E4%B9%A0/</guid>
      <description>websocet学习 什么是websocket WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。传统的http下需要客户端进行请求然后服务端再给客户端发送数据。传统的http协议也可以实现近似即时获取服务端的信息，采用轮询的方式，但是这种方式有两种弊端，一种是消息获取不够及时，另外就是频繁的请求给服务器造成较大的压力，因此，html5推出了WebSocket标准，让浏览器和服务器之间可以建立无限制的全双工通信，任何一方都可以主动发消息给对方。
webscoket协议 原理 websocket实际基于tcp协议，websocket的连接需要浏览器发起，因为请求是一个标准的http请求 请求头
GET ws://localhost:3000/test HTTP/1.1 Host: localhost:3000 Connection: Upgrade Upgrade: websocket Origin: http://localhost:3000 Sec-WebSocket-Version: 13 Sec-WebSocket-Key: BQd6Enl4SAdoXWEtrEaq2g== Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits 该请求和普通的http请求有几点不同
 GET请求的地址不是类似/path/，而是以ws://开头的地址； 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接； Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据； Sec-WebSocket-Version指定了WebSocket的协议版本。 响应头  HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: NARaYzkyb+yRTBQNm/xBtlvB8sQ= 该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。
浏览器 要支持websocket，浏览器需要支持这个协议，这样才能发出ws://xxx的请求，安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。
服务器 由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身
客户端api websocket构造函数 websocket对象作为一个构造函数，用于新建websocket实例
var ws= new WebSocket(&amp;#39;ws://localhost:8080&amp;#39;); websocket属性 webSocket.readyState: readyState属性返回实例对象的当前状态，共有四种
 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。  webSocket.bufferedAmount: 实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。
websocket事件  webSocket.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c#/c%23%E4%B8%AD%E7%9A%84is%E5%92%8Cas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c#/c%23%E4%B8%AD%E7%9A%84is%E5%92%8Cas/</guid>
      <description>c#中的is和as的用法 c# 中 is和as 操作符是用来进行强制类型转换的
is 检查一个对象是否兼容于其他指定的类型，并返回于一个bool值，不会抛出异常
object o = new object(); if (o is Label) { Label lb = (Label)o; Response.Write(&amp;#34;类型转换成功&amp;#34;); } else { Response.Write(&amp;#34;类型转换失败&amp;#34;); } 在上面的代码,CLR实际上会检查两次对象的类型,is操作符先核实一次,如果o兼容于Lable,那么在(Label)o时会再次核实一次,效率比较低,不建议使用
as as的作用与is的作用是一致的，但是效率要高于is，不会抛出异常，如果无法转换，会抛出null；请注意，as 运算符仅执行引用转换、可以为 null 的转换和装箱转换。 as 运算符无法执行其他转换，例如用户定义的转换，应使用转换表达式执行此转换。
object o = new object(); Label lb = o as Label; if (lb == null) { Response.Write(&amp;#34;类型转换失败&amp;#34;); } else { Response.Write(&amp;#34;类型转换成功&amp;#34;); } 在上面的代码中,CLR只会进行一次类型核实,效率要高于 is</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/note/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c#/c%23%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c#/c%23%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/</guid>
      <description>c# 委托与事件 委托的定义 委托是一种引用类型，表示对具有特定参数列表和返回类型的方法的引用。 在实例化委托时，可以将其实例与任何具有兼容签名和返回类型的方法相关联。 可以通过委托实例调用方法，委托用于将方法作为参传递给其他方法，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。事件处理程序，就是通过委托调用的方法，如我们可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。 下面的示例演示了一个委托声明：
public delegate int DoEventHandler(); delegate是关键词，而一般的方法是下面的这个样子
public void Do() { 方法体 } 区别主要在于，委托是一个命令，真正执行的是别的方法
使用委托 以一个具体的情境为例：GreetingPeople 定义委托
public delegate void GreetingDelegate(string name); 定义GreetPeople方法
public void GreetPeople(string name, GreetingDelegate MakeGreeting){ MakeGreeting(name); } 完整代码
public delegate void GreetingDelegate(string name); class Program { private static void EnglishGreeting(string name) { Console.WriteLine(&amp;#34;Morning, &amp;#34; + name); } private static void ChineseGreeting(string name) { Console.WriteLine(&amp;#34;早上好, &amp;#34; + name); } //此方法接受一个GreetingDelegate类型的方法作为参数  private static void GreetPeople(string name, GreetingDelegate MakeGreeting) { MakeGreeting(name); } static void Main(string[] args) { GreetPeople(&amp;#34;Jimmy Zhang&amp;#34;, EnglishGreeting); GreetPeople(&amp;#34;张子阳&amp;#34;, ChineseGreeting); Console.</description>
    </item>
    
    <item>
      <title>vscode快捷键</title>
      <link>https://example.com/note/tools/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/note/tools/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description> 打开系统设置的键盘快捷方式 ctrl+k,ctrl+s 更换语言模式 ctrl+K+M 打开终端 ctrl+shift+Y 打开所有命令 F1/ctrl+shift+P 转到文件 ctrl+P 切换侧边栏 ctrl+b 在文件夹中查找 ctrl+shift+b 在文件夹中查找并替换 ctrl+shift+h 代码格式化 shfit+alt+f  </description>
    </item>
    
  </channel>
</rss>
