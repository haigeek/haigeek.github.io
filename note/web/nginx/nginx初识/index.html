
<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml"  lang="en">

    <head>

        
        <meta charset="UTF-8" />

        
        <meta name="viewport" content="width=device-width, initial-scale=1"/>

                
        <title> 
               
        </title>
        
        
            <link href="https://example.com/index.xml" rel="alternate" type="application/rss+xml" title="Kiss&#39;Em!" />
        

        
        <link rel="stylesheet" href="/css/style.css"/>

        
        
            <link rel='stylesheet' href='https://example.com/css/custom.css'>
        
        
    </head>

    <body>



<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://example.com">
          <h1 id="nav-heading" class="title is-4">Kiss&#39;Em!</h1>
        </a>
      </div>
      <div class="nav-right">
        
        
        <nav id="nav-items" class="nav-item level is-mobile">
          <a class="level-item" aria-label="about" href='/about'
           rel='noopener'>
            <span class="icon">
              <i class>

<svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="8"></line>
    
  </svg></i>
            </span>
          </a>
          <a class="level-item" aria-label="email" href='mailto:info@pavel-pi.de'
           target='_blank'  rel='noopener'>
            <span class="icon">
              <i class>

<svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
    
  </svg></i>
            </span>
          </a>
          <a class="level-item" aria-label="github" href='https://github.com/pavel-pi'
           target='_blank'  rel='noopener'>
            <span class="icon">
              <i class>

<svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a>
          <a class="level-item" aria-label="twitter" href='https://twitter.com/@_pavel_pi_'
           target='_blank'  rel='noopener'>
            <span class="icon">
              <i class>

<svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a>
          <a class="level-item" aria-label="rss" href='/index.xml'
           target='_blank'  rel='noopener'>
            <span class="icon">
              <i class>

<svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
    
  </svg></i>
            </span>
          </a></nav>
        
      
      </div>
    </nav>

    <nav class="nav">
      

      
    </nav>

  </div>
</section>

<section class="section">
    
    <div class="container">
    
        
            
<div class="subtitle tags is-6 is-pulled-right">
    
</div>





<h1 class="title"></h1>

<div class="content">

    
    <h1 id="nginx初识">Nginx初识</h1>
<h2 id="nginx是什么">Nginx是什么</h2>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->Nginx 是一个免费的，开源的，高性能的HTTP服务器和反向代理，以及IMAP / POP3代理服务器。 Nginx 以其高性能，稳定性，丰富的功能，简单的配置和低资源消耗而闻名。<!-- raw HTML omitted --><!-- raw HTML omitted -->
Nginx的整体架构如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/84598/1550064535770-194eeb7e-1a15-42dd-ba16-9f3e15ba8ee5.png" alt="image.png | left | 827x514" title=""></p>
<p>nginx在启动后，会以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程。工作进程以非特权用户运行。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。worker进程则是处理基本的网络事件。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->nginx包含3类模块：核心模块，基础模块，第三方模块<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<ul>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->ht_core核心模块<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->ht_upstream 基础模块<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->ht_proxy 基础模块<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->ht_fastcgi 基础模块<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->还可以添加一些第三方模块，例如memcache客户端和后端的memcached通信。<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->nginx使用事件驱动模式来处理请求，异步I/O，非阻塞，事件模式是epoll/select等，非常高效，内存使用mmap、aio，高级io  sendfile。<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>Nginx的高并发，官方测试支持5万并发连接。实际生产环境能到2-3万并发连接数。10000个非活跃的HTTP keep-alive 连接仅占用约2.5MB内存。三万并发连接下，10个Nginx进程，消耗内存150M。淘宝tengine团队说测试结果是“24G内存机器上，处理并发请求可达200万”。</p>
<h2 id="安装">安装</h2>
<h3 id="windows安装">windows安装</h3>
<p>下载地址：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a>
选择windows版本下载后解压</p>
<h3 id="linux安装与相关操作">Linux安装与相关操作</h3>
<ol>
<li>相关库的安装</li>
</ol>
<pre><code>yum update -y  
yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel  
</code></pre><ul>
<li>PCRE pcre-devel
PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。</li>
<li>zlib
zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</li>
<li>OpenSSL
OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。
nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</li>
</ul>
<ol start="2">
<li>下载源码</li>
</ol>
<pre><code>wget http://nginx.org/download/nginx-1.8.1.tar.gz 
</code></pre><ol start="3">
<li>编译安装</li>
</ol>
<pre><code>tar -zxvf nginx-1.8.1.tar.gz  
cd nginx-1.8.1/   
./configure  
make   
make install  
</code></pre><ol start="4">
<li>配置反向代理</li>
</ol>
<pre><code>cd /usr/local/nginx/conf   
vi nginx.conf  
</code></pre><ol start="5">
<li>nginx相关操作</li>
</ol>
<pre><code>cd /usr/local/nginx/sbin  
./nginx #启动  
./nginx -s stop #停止
./nginx -s reload #更新配置文件
</code></pre><h2 id="正向代理和反向代理">正向代理和反向代理</h2>
<h3 id="正向代理">正向代理</h3>
<ol>
<li><!-- raw HTML omitted --><!-- raw HTML omitted -->用户希望代理服务器帮助自己，和要访问服务器通信，那么需要以下信息<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->a) 用户IP报文的目的IP = 代理服务器IP<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->b) 用户报文端口号 = 代理服务器监听端口号<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->c) HTTP 消息里的URL要提供服务器的链接<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li>代理服务器根据c中提供的链接直接与服务器进行通信</li>
<li>服务器返回网页</li>
<li>代理服务器将返回的网页返回给用户
<!-- raw HTML omitted --><!-- raw HTML omitted -->正向代理类似一个跳板机，把浏览器访问过程委托给代理去做，代理访问外部资源。<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/84598/1549979030433-d90ea45b-596e-4684-be81-16aa618b081d.png" alt="image.png | left | 747x149" title=""></p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->举个例子：<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从目标网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->类似场景比如我们在外网去访问公司内网服务器B，我们先设置VPN，通过VPN将我们的请求转发到内网的A服务器，然后A把请求发到B上，响应内容返回到A，再由A通过VPN返回到我们。<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->工作流程可以描述为：<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->用户设置代理服务器，用户访问url，代理服务器代替用户访问并将网页内容返回。<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="反向代理">反向代理</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->在计算机世界里，由于单个服务器的处理客户端（用户）请求能力有一个极限，当用户的接入请求蜂拥而入时，会造成服务器忙不过来的局面，可以使用多个服务器来共同分担成千上万的用户请求，这些服务器提供相同的服务。实现反向代理，需要满足以下条件：<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<ol>
<li>需要有一个负载均衡设备来分发用户请求，将用户请求分发到空闲的服务器上</li>
<li>服务器返回自己的服务到负载均衡设备</li>
<li>负载均衡将服务器的服务返回用户
<!-- raw HTML omitted --><!-- raw HTML omitted -->用户和负载均衡设备直接通信，<!-- raw HTML omitted --><!-- raw HTML omitted --><strong>也意味着用户做服务器域名解析时，解析得到的IP其实是负载均衡的IP，而不是服务器的IP</strong><!-- raw HTML omitted --><!-- raw HTML omitted -->，这样有一个好处是，当新加入/移走服务器时，仅仅需要修改负载均衡的服务器列表，而不会影响现有的服务。<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ol>
<p><strong>反向代理（Reverse Proxy）</strong><!-- raw HTML omitted --><!-- raw HTML omitted -->方式是指后台内部网络服务器委托代理服务器，以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->用户访问的是代理服务器，前端是不知道后台真实地址，只知道代理地址。<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/84598/1549979095220-8d825b38-b379-4b0d-85f2-aea8d6cea8e1.png" alt="image.png | left | 747x212" title=""></p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->再举个栗子：<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->我是一个用户，我可以访问某一个网站，网站的数据是来源于我访问不到的内部网络上的内容服务器，内容服务器设置了可以访问自己的代理服务器。于是我向目标内容服务器发起请求，其实我访问的是内容服务器设置的代理服务器，这个代理服务器将我的请求转发到目标内容服务器上，获取到数据后再返回给网站上，我就可以看见了。<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/84598/1549979127366-63b27c10-3d04-4338-887c-1efcd2bb58ac.png" alt="image.png | left | 650x436" title=""></p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->工作流程可以描述为：<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted -->和正向代理相反，由目标内容服务器设置代理服务器，代理转发用户发起的请求，获取数据再返回给用户。<!-- raw HTML omitted --><!-- raw HTML omitted -->
简单来说：正向代理代理客户端，反向代理代理服务器。</p>
<h2 id="nginx主要配置解析">Nginx主要配置解析</h2>
<p>Nginx使用Block(如 <code>server block</code>, <code>location block</code>)来组成配置文件的层级结构，并在接收到客户端请求之后根据请求的域名(domain name)，端口(port)，IP地址判断处理该请求的<code>server block</code>，然后根据请求的资源和URI决定处理该请求的<code>location block</code></p>
<h3 id="虚拟主机和请求的分发">虚拟主机和请求的分发</h3>
<h4 id="1域名和端口的配置">1、域名和端口的配置</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain"># IP地址和端口
listen 127.0.0.1:8000;
listen localhost:8000;
# 仅端口 监听所有接口为这个port的请求
listen *:8000;
</code></pre></div><h4 id="2-主机名配置">2、 主机名配置</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">server_name www.barretlee.com barretlee.com
# 选择以*开头的进行匹配，并优先选择最长的。
server_name *.barretlee.com
# 选择以*结尾的进行匹配，并优先选择最长的。
server_name barretlee.com.*
# 以~开头的表示以正则表达式进行匹配， “^” 和 “$” 锚定符对主机名进行界定，域名的分隔符 “.” 在正则表达式中应该以 “\” 引用
server_name ~^\.barret\.com$
</code></pre></div><p>如果以上规则都无法匹配，则选择<code>default_server</code>定义的默认的<code>server_block</code>（每个<code>server_block</code>只能有一个<code>default_server</code>），默认的default_server是localhost</p>
<h4 id="3location-block是server-block的一部分决定了如何处理请求的uri">3、<code>location block</code>是<code>server block</code>的一部分，决定了如何处理请求的URI</h4>
<p><code>modifier</code>是一个可选的参数，决定了如何解析后面的<code>location match</code>，modifier可选的值有:</p>
<ol>
<li>(none)
前缀匹配， 如
<pre><code>location /site {
    ...
}
</code></pre><p>将匹配以<code>/site</code>开头的URI</p>
</li>
<li>=(equal sign)
完整匹配，如
<pre><code>location = /page {
    ...
}
</code></pre><p>将匹配<code>/page</code>,而不会响应<code>/page/index.html</code>的请求</p>
</li>
<li>~(tilde)
大小写敏感的正则匹配, 如
<pre><code>location ~ \.(jpe?g|png|gif|ico)$ {
...
}
</code></pre><p>将匹配以<code>.jpg/.jpeg/.png/.gif/.ico</code>结尾的URI, 但不会响应<code>.JPG</code></p>
</li>
<li>~*(tilde + asterisk)
大小写无关的正则匹配, 如
<pre><code>location ~* \.(jpe?g|png|gif|ico)$ {
    ...
}
</code></pre><p><code>.jpg</code>和<code>.JPG</code>都会匹配</p>
</li>
<li>^~(carat + tilde)
非正则匹配，如
<pre><code>location ^~ /page {
    ...
}
</code></pre><p>能够匹配<code>/page/index.html</code></p>
</li>
</ol>
<p><strong>匹配顺序</strong>
Nginx优先选择正则表达式进行匹配，但是使用<code>=</code>和<code>^~（非正则匹配）</code>这两个<code>modifier</code>可以覆盖这一特性。排序对匹配过程也有一定的影响，因为Nginx在匹配到最长最精确的location之后就会停止匹配。</p>
<ol>
<li>将所有非正则表达式的<code>location_match</code>与请求的URI进行对比。</li>
<li>与<code>modifier</code>为<code>=</code>的进行完整匹配。</li>
<li>选择最长<code>location_match</code>前缀进行匹配，如果<code>modifier</code>为<code>^~</code>则匹配成功。</li>
<li>进行正则表达式匹配</li>
<li>用其他前缀匹配</li>
</ol>
<p><strong>注意：</strong>
<strong>proxy_pass的url是否存在 / 的区别</strong></p>
<pre><code>location  /proxy/ {
	proxy_pass http://127.0.0.1/;
}
</code></pre><p>访问：<code>127.0.0.1/proxy/a.jpg</code>：则会请求到：<a href="https://link.juejin.im?target=http%3A%2F%2F127.0.0.1%2Fa.jpg">http://127.0.0.1/a.jpg</a></p>
<pre><code>location  /proxy/ {
	proxy_pass http://127.0.0.1;
}
</code></pre><p>访问：<code>127.0.0.1/proxy/a.jpg</code>：则会请求到：<a href="https://link.juejin.im?target=http%3A%2F%2F127.0.0.1%2Fproxy%2Fa.jpg">http://127.0.0.1/proxy/a.jpg</a></p>
<p><strong>“location /xxx/” 与“location ^~ /xxx/”区别</strong></p>
<pre><code>location = / {   #表示匹配访问根目录
	root   html;   #当前安装目录下的html，/html则表示服务器根目录下的html
	index  index.html index.htm;
}
location /svn/ {   #表示匹配ip:port/svn/
	root /data/;
	autoindex on;
}
}
location ^~ /svn/ {   #表示只要含有svn/就会被匹配
	root /data/;
	autoindex on;
}
</code></pre><h4 id="4其他指令">4、其他指令</h4>
<ol>
<li>
<p>index
语法：<code>index file ...;</code> 默认为<code>index index.html;</code>
<code>index</code>指令指定了被作为index的文件，比如上面的<code>index.html</code>
但是在下面这种情况下，对<code>/index.html</code>的请求将会被第二个<code>location block</code>处理，因为第一个与<code>/index.html</code>并不是完全匹配。</p>
<pre><code>location = / {
    index index.html;
}
location / {
    ...
}
</code></pre></li>
<li>
<p>根目录设置</p>
<pre><code>location / {
    root /home/barret/test/;
}
</code></pre></li>
<li>
<p>try_files</p>
<pre><code>root /var/www/main;
location / {    try_files $uri $uri.html $uri/ /fallback/index.html;
}
location /fallback {
    root /var/www/another;
}
</code></pre><p>对<code>/page</code>的请求将会首先进入第一个location, 然后尝试在<code>/var/www/main</code> 下依次查找<code>page</code>, <code>page.html</code>, <code>page/</code>，如果都没有找到的话将会被重定向到<code>/fallback/index.html</code>，并由第二个location提供<code>/var/www/another/fallback/index.html</code></p>
</li>
<li>
<p>重定向配置
重定向页面设置</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">error_page    404         /404.html;
error_page    502  503    /50x.html;
error_page    404  =200   /1x1.gif;
location / {
error_page  404 @fallback;
}
location @fallback {
# 将请求反向代理到上游服务器处理
proxy_pass http://localhost:9000;
}
</code></pre></div></li>
<li>
<p>error_page</p>
<pre><code>root /var/www/main;
location / {    error_page 404 /another/whoops.html;
}
    
location /another {
    root /var/www;
}
</code></pre><p>除了<code>/another</code>之外的请求都会在<code>/var/www/main</code>查找请求的资源，如果没有找到相关资源将会重定向到<code>/another/whoops.html</code>，由第二个<code>location block</code>处理，查找<code>/var/www/another/whoops.html</code></p>
</li>
</ol>
<h3 id="反向代理配置">反向代理配置</h3>
<p>proxy_pass 将请求转发到有处理能力的端上，默认不会转发请求中的 Host 头部</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">location /blog {
prox_pass http://localhost:9000;
### 下面都是次要关注项
proxy_set_header Host $host;
proxy_method POST;
# 指定不转发的头部字段
proxy_hide_header Cache-Control;
proxy_hide_header Other-Header;
# 指定转发的头部字段
proxy_pass_header Server-IP;
proxy_pass_header Server-Name;
# 是否转发包体
proxy_pass_request_body on | off;
# 是否转发头部
proxy_pass_request_headers on | off;
# 显形/隐形 URI，上游发生重定向时，Nginx 是否同步更改 uri
proxy_redirect on | off;
}
</code></pre></div>

    
    
        <div class="related">

</div>
    

</div>


        

    </div>

</section>



<section class="section">
  <div class="container has-text-centered">
    <p>© <a href="https://github.com/pavel-pi">Pavel Pi</a> 2020</p>
    
      <p>Powered by <a href="https://gohugo.io/">Hugo</a> &amp; <a href="https://github.com/pavel-pi/kiss-em">Kiss'Em</a>.</p>
    
  </div>
</section>

</body>
</html>

